<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage_filtered.info - Nexus/src/registry/SharedMemoryRegistry.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">Nexus/src/registry</a> - SharedMemoryRegistry.cpp<span style="font-size: 80%;"> (source / <a href="SharedMemoryRegistry.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage_filtered.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">434</td>
            <td class="headerCovTableEntry">509</td>
            <td class="headerCovTableEntryMed">85.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2025-12-18 17:31:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">19</td>
            <td class="headerCovTableEntry">20</td>
            <td class="headerCovTableEntryHi">95.0 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #include &quot;nexus/registry/SharedMemoryRegistry.h&quot;</a>
<a name="2"><span class="lineNum">       2 </span>            : </a>
<a name="3"><span class="lineNum">       3 </span>            : #include &lt;fcntl.h&gt;</a>
<a name="4"><span class="lineNum">       4 </span>            : #include &lt;signal.h&gt;</a>
<a name="5"><span class="lineNum">       5 </span>            : #include &lt;sys/file.h&gt;  // For flock()</a>
<a name="6"><span class="lineNum">       6 </span>            : #include &lt;sys/mman.h&gt;</a>
<a name="7"><span class="lineNum">       7 </span>            : #include &lt;sys/stat.h&gt;</a>
<a name="8"><span class="lineNum">       8 </span>            : #include &lt;unistd.h&gt;</a>
<a name="9"><span class="lineNum">       9 </span>            : </a>
<a name="10"><span class="lineNum">      10 </span>            : #include &lt;cerrno&gt;  // For errno</a>
<a name="11"><span class="lineNum">      11 </span>            : #include &lt;chrono&gt;</a>
<a name="12"><span class="lineNum">      12 </span>            : #include &lt;cstring&gt;</a>
<a name="13"><span class="lineNum">      13 </span>            : #include &lt;ctime&gt;  // For time()</a>
<a name="14"><span class="lineNum">      14 </span>            : #include &lt;iostream&gt;</a>
<a name="15"><span class="lineNum">      15 </span>            : #include &lt;set&gt;  // For alive_pids deduplication</a>
<a name="16"><span class="lineNum">      16 </span>            : #include &lt;thread&gt;</a>
<a name="17"><span class="lineNum">      17 </span>            : </a>
<a name="18"><span class="lineNum">      18 </span>            : #include &quot;nexus/utils/Logger.h&quot;</a>
<a name="19"><span class="lineNum">      19 </span>            : </a>
<a name="20"><span class="lineNum">      20 </span>            : // QNX specific includes</a>
<a name="21"><span class="lineNum">      21 </span>            : #ifdef __QNXNTO__</a>
<a name="22"><span class="lineNum">      22 </span>            : #include &lt;sys/neutrino.h&gt;</a>
<a name="23"><span class="lineNum">      23 </span>            : #endif</a>
<a name="24"><span class="lineNum">      24 </span>            : </a>
<a name="25"><span class="lineNum">      25 </span>            : namespace Nexus {</a>
<a name="26"><span class="lineNum">      26 </span>            : namespace rpc {</a>
<a name="27"><span class="lineNum">      27 </span>            : </a>
<a name="28"><span class="lineNum">      28 </span><span class="lineCov">        247 : SharedMemoryRegistry::SharedMemoryRegistry()</span></a>
<a name="29"><span class="lineNum">      29 </span><span class="lineCov">        247 :     : initialized_(false), shm_ptr_(nullptr), shm_fd_(-1), registry_(nullptr) {}</span></a>
<a name="30"><span class="lineNum">      30 </span>            : </a>
<a name="31"><span class="lineNum">      31 </span><span class="lineCov">        246 : SharedMemoryRegistry::~SharedMemoryRegistry() {</span></a>
<a name="32"><span class="lineNum">      32 </span><span class="lineCov">        246 :     if (initialized_ &amp;&amp; registry_) {</span></a>
<a name="33"><span class="lineNum">      33 </span>            :         // ğŸ”§ CRITICAL: ä½¿ç”¨é”ä¿æŠ¤ææ„æ“ä½œï¼Œé˜²æ­¢å¹¶å‘è®¿é—®</a>
<a name="34"><span class="lineNum">      34 </span><span class="lineCov">        229 :         int lock_result = pthread_mutex_lock(&amp;registry_-&gt;header.global_lock);</span></a>
<a name="35"><span class="lineNum">      35 </span><span class="lineCov">        229 :         bool should_cleanup = false;</span></a>
<a name="36"><span class="lineNum">      36 </span>            : </a>
<a name="37"><span class="lineNum">      37 </span><span class="lineCov">        229 :         if (lock_result == EOWNERDEAD) {</span></a>
<a name="38"><span class="lineNum">      38 </span>            :             // ä¸Šä¸€ä¸ªæŒæœ‰é”çš„è¿›ç¨‹å´©æºƒï¼Œæ¢å¤é”çŠ¶æ€</a>
<a name="39"><span class="lineNum">      39 </span><span class="lineCov">          1 :             NEXUS_LOG_WARN(&quot;Registry&quot;, &quot;Recovered mutex from dead process in destructor&quot;);</span></a>
<a name="40"><span class="lineNum">      40 </span><span class="lineCov">          1 :             pthread_mutex_consistent(&amp;registry_-&gt;header.global_lock);</span></a>
<a name="41"><span class="lineNum">      41 </span>            :         }</a>
<a name="42"><span class="lineNum">      42 </span>            : </a>
<a name="43"><span class="lineNum">      43 </span><span class="lineCov">        229 :         if (lock_result == 0 || lock_result == EOWNERDEAD) {</span></a>
<a name="44"><span class="lineNum">      44 </span>            :             // ğŸ”§ CRITICAL: ä» ref_pids ä¸­ç§»é™¤å½“å‰è¿›ç¨‹PID</a>
<a name="45"><span class="lineNum">      45 </span><span class="lineCov">        229 :             pid_t my_pid = getpid();</span></a>
<a name="46"><span class="lineNum">      46 </span><span class="lineCov">       1515 :             for (size_t i = 0; i &lt; MAX_REGISTRY_ENTRIES; ++i) {</span></a>
<a name="47"><span class="lineNum">      47 </span><span class="lineCov">       1515 :                 uint32_t expected = my_pid;</span></a>
<a name="48"><span class="lineNum">      48 </span><span class="lineCov">       3030 :                 if (registry_-&gt;header.ref_pids[i].compare_exchange_strong(expected, 0, std::memory_order_release)) {</span></a>
<a name="49"><span class="lineNum">      49 </span><span class="lineCov">        229 :                     break;</span></a>
<a name="50"><span class="lineNum">      50 </span>            :                 }</a>
<a name="51"><span class="lineNum">      51 </span>            :             }</a>
<a name="52"><span class="lineNum">      52 </span>            : </a>
<a name="53"><span class="lineNum">      53 </span>            :             // ğŸ”§ é€’å‡å¼•ç”¨è®¡æ•°</a>
<a name="54"><span class="lineNum">      54 </span><span class="lineCov">        229 :             uint32_t prev_count = registry_-&gt;header.ref_count.fetch_sub(1, std::memory_order_acq_rel);</span></a>
<a name="55"><span class="lineNum">      55 </span><span class="lineCov">        229 :             NEXUS_LOG_INFO(&quot;Registry&quot;, &quot;Decremented ref_count: &quot; + std::to_string(prev_count) + &quot; -&gt; &quot; +</span></a>
<a name="56"><span class="lineNum">      56 </span>            :                                            std::to_string(prev_count - 1));</a>
<a name="57"><span class="lineNum">      57 </span>            : </a>
<a name="58"><span class="lineNum">      58 </span>            :             // ğŸ”§ ä¿®æ­£ï¼šåœ¨é”å†…åˆ¤æ–­æ˜¯å¦æ˜¯æœ€åä¸€ä¸ªï¼Œé˜²æ­¢ç«æ€æ¡ä»¶</a>
<a name="59"><span class="lineNum">      59 </span>            :             // å†æ¬¡æ£€æŸ¥å½“å‰ ref_countï¼Œç¡®è®¤æ˜¯ 0</a>
<a name="60"><span class="lineNum">      60 </span><span class="lineCov">        229 :             uint32_t current_count = registry_-&gt;header.ref_count.load(std::memory_order_acquire);</span></a>
<a name="61"><span class="lineNum">      61 </span><span class="lineCov">        229 :             should_cleanup = (current_count == 0);</span></a>
<a name="62"><span class="lineNum">      62 </span>            : </a>
<a name="63"><span class="lineNum">      63 </span>            :             // ğŸ”§ CRITICAL: è§£é”ä½†ä¸ç«‹å³é”€æ¯ï¼Œç­‰munmapåå†é”€æ¯</a>
<a name="64"><span class="lineNum">      64 </span><span class="lineCov">        229 :             pthread_mutex_unlock(&amp;registry_-&gt;header.global_lock);</span></a>
<a name="65"><span class="lineNum">      65 </span><span class="lineCov">        229 :         } else {</span></a>
<a name="66"><span class="lineNum">      66 </span><span class="lineNoCov">          0 :             NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Failed to acquire lock in destructor: &quot; + std::string(strerror(lock_result)));</span></a>
<a name="67"><span class="lineNum">      67 </span>            :         }</a>
<a name="68"><span class="lineNum">      68 </span>            : </a>
<a name="69"><span class="lineNum">      69 </span>            :         // ğŸ”§ å…ˆ munmap å† destroy mutexï¼Œé˜²æ­¢è®¿é—®å·²é‡Šæ”¾çš„å†…å­˜</a>
<a name="70"><span class="lineNum">      70 </span><span class="lineCov">        229 :         if (shm_ptr_ &amp;&amp; shm_ptr_ != MAP_FAILED) {</span></a>
<a name="71"><span class="lineNum">      71 </span><span class="lineCov">        229 :             munmap(shm_ptr_, sizeof(RegistryRegion));</span></a>
<a name="72"><span class="lineNum">      72 </span><span class="lineCov">        229 :             shm_ptr_ = nullptr;</span></a>
<a name="73"><span class="lineNum">      73 </span>            :         }</a>
<a name="74"><span class="lineNum">      74 </span><span class="lineCov">        229 :         if (shm_fd_ &gt;= 0) {</span></a>
<a name="75"><span class="lineNum">      75 </span><span class="lineCov">        229 :             close(shm_fd_);</span></a>
<a name="76"><span class="lineNum">      76 </span><span class="lineCov">        229 :             shm_fd_ = -1;</span></a>
<a name="77"><span class="lineNum">      77 </span>            :         }</a>
<a name="78"><span class="lineNum">      78 </span>            : </a>
<a name="79"><span class="lineNum">      79 </span><span class="lineCov">        229 :         registry_ = nullptr;</span></a>
<a name="80"><span class="lineNum">      80 </span>            : </a>
<a name="81"><span class="lineNum">      81 </span><span class="lineCov">        229 :         if (should_cleanup) {</span></a>
<a name="82"><span class="lineNum">      82 </span>            :             // æœ€åä¸€ä¸ªè¿›ç¨‹ï¼Œå°è¯•æ¸…ç†</a>
<a name="83"><span class="lineNum">      83 </span><span class="lineCov">        122 :             cleanupOrphanedRegistry();</span></a>
<a name="84"><span class="lineNum">      84 </span>            :         }</a>
<a name="85"><span class="lineNum">      85 </span>            :     }</a>
<a name="86"><span class="lineNum">      86 </span><span class="lineCov">        246 : }</span></a>
<a name="87"><span class="lineNum">      87 </span>            : </a>
<a name="88"><span class="lineNum">      88 </span><span class="lineCov">        242 : bool SharedMemoryRegistry::initialize() {</span></a>
<a name="89"><span class="lineNum">      89 </span><span class="lineCov">        242 :     if (initialized_) {</span></a>
<a name="90"><span class="lineNum">      90 </span><span class="lineCov">          2 :         return true;</span></a>
<a name="91"><span class="lineNum">      91 </span>            :     }</a>
<a name="92"><span class="lineNum">      92 </span>            : </a>
<a name="93"><span class="lineNum">      93 </span>            :     // ğŸ”§ å°è¯•åˆ›å»ºæ–°çš„registryï¼ˆä½¿ç”¨O_EXCLç¡®ä¿åŸå­æ€§ï¼‰</a>
<a name="94"><span class="lineNum">      94 </span><span class="lineCov">        240 :     shm_fd_ = shm_open(REGISTRY_SHM_NAME, O_CREAT | O_EXCL | O_RDWR, 0666);</span></a>
<a name="95"><span class="lineNum">      95 </span><span class="lineCov">        240 :     bool creating = (shm_fd_ &gt;= 0);</span></a>
<a name="96"><span class="lineNum">      96 </span>            : </a>
<a name="97"><span class="lineNum">      97 </span><span class="lineCov">        240 :     if (!creating) {</span></a>
<a name="98"><span class="lineNum">      98 </span>            :         // Registryå·²å­˜åœ¨ï¼Œå°è¯•æ‰“å¼€</a>
<a name="99"><span class="lineNum">      99 </span><span class="lineCov">        116 :         shm_fd_ = shm_open(REGISTRY_SHM_NAME, O_RDWR, 0666);</span></a>
<a name="100"><span class="lineNum">     100 </span><span class="lineCov">        116 :         if (shm_fd_ &lt; 0) {</span></a>
<a name="101"><span class="lineNum">     101 </span><span class="lineNoCov">          0 :             NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Failed to open registry: &quot; + std::string(strerror(errno)));</span></a>
<a name="102"><span class="lineNum">     102 </span><span class="lineCov">          4 :             return false;</span></a>
<a name="103"><span class="lineNum">     103 </span>            :         }</a>
<a name="104"><span class="lineNum">     104 </span>            : </a>
<a name="105"><span class="lineNum">     105 </span>            :         // ğŸ”§ CRITICAL: æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼Œé˜²æ­¢ mmap æŸåçš„ registry</a>
<a name="106"><span class="lineNum">     106 </span>            :         struct stat st;</a>
<a name="107"><span class="lineNum">     107 </span><span class="lineCov">        116 :         if (fstat(shm_fd_, &amp;st) == 0) {</span></a>
<a name="108"><span class="lineNum">     108 </span><span class="lineCov">        116 :             if (st.st_size == 0) {</span></a>
<a name="109"><span class="lineNum">     109 </span><span class="lineCov">          2 :                 NEXUS_LOG_WARN(&quot;Registry&quot;, &quot;Found empty registry file (size=0), previous creator may have failed&quot;);</span></a>
<a name="110"><span class="lineNum">     110 </span>            :                 // å°è¯•é‡æ–°è®¾ç½®å¤§å°</a>
<a name="111"><span class="lineNum">     111 </span><span class="lineCov">          2 :                 if (ftruncate(shm_fd_, sizeof(RegistryRegion)) &lt; 0) {</span></a>
<a name="112"><span class="lineNum">     112 </span><span class="lineNoCov">          0 :                     NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Failed to resize corrupted registry: &quot; + std::string(strerror(errno)));</span></a>
<a name="113"><span class="lineNum">     113 </span><span class="lineNoCov">          0 :                     close(shm_fd_);</span></a>
<a name="114"><span class="lineNum">     114 </span><span class="lineNoCov">          0 :                     shm_fd_ = -1;</span></a>
<a name="115"><span class="lineNum">     115 </span><span class="lineNoCov">          0 :                     return false;</span></a>
<a name="116"><span class="lineNum">     116 </span>            :                 }</a>
<a name="117"><span class="lineNum">     117 </span><span class="lineCov">          2 :                 creating = true;  // æ ‡è®°ä¸ºéœ€è¦åˆå§‹åŒ–</span></a>
<a name="118"><span class="lineNum">     118 </span><span class="lineCov">          2 :                 NEXUS_LOG_INFO(&quot;Registry&quot;, &quot;Resized empty registry, will reinitialize&quot;);</span></a>
<a name="119"><span class="lineNum">     119 </span><span class="lineCov">        114 :             } else if (st.st_size != sizeof(RegistryRegion)) {</span></a>
<a name="120"><span class="lineNum">     120 </span><span class="lineCov">          4 :                 NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Registry size incorrect: expected &quot; +</span></a>
<a name="121"><span class="lineNum">     121 </span>            :                                                 std::to_string(sizeof(RegistryRegion)) + &quot;, got &quot; +</a>
<a name="122"><span class="lineNum">     122 </span>            :                                                 std::to_string(st.st_size));</a>
<a name="123"><span class="lineNum">     123 </span><span class="lineCov">          4 :                 close(shm_fd_);</span></a>
<a name="124"><span class="lineNum">     124 </span><span class="lineCov">          4 :                 shm_fd_ = -1;</span></a>
<a name="125"><span class="lineNum">     125 </span><span class="lineCov">          4 :                 return false;</span></a>
<a name="126"><span class="lineNum">     126 </span>            :             }</a>
<a name="127"><span class="lineNum">     127 </span>            :         }</a>
<a name="128"><span class="lineNum">     128 </span>            :     } else {</a>
<a name="129"><span class="lineNum">     129 </span>            :         // æˆåŠŸåˆ›å»ºæ–°registryï¼Œè®¾ç½®å¤§å°</a>
<a name="130"><span class="lineNum">     130 </span><span class="lineCov">        124 :         if (ftruncate(shm_fd_, sizeof(RegistryRegion)) &lt; 0) {</span></a>
<a name="131"><span class="lineNum">     131 </span><span class="lineNoCov">          0 :             NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Failed to set size (errno=&quot; + std::to_string(errno) +</span></a>
<a name="132"><span class="lineNum">     132 </span>            :                                             &quot;): &quot; + std::string(strerror(errno)));</a>
<a name="133"><span class="lineNum">     133 </span><span class="lineNoCov">          0 :             close(shm_fd_);</span></a>
<a name="134"><span class="lineNum">     134 </span><span class="lineNoCov">          0 :             shm_fd_ = -1;</span></a>
<a name="135"><span class="lineNum">     135 </span>            :             // ğŸ”§ SAFE: åˆ›å»ºè€…åœ¨è¿™é‡Œå¤±è´¥æ—¶å¯ä»¥åˆ é™¤ï¼Œå› ä¸ºï¼š</a>
<a name="136"><span class="lineNum">     136 </span>            :             // 1. magic è¿˜æœªè®¾ç½®ï¼Œå…¶ä»–è¿›ç¨Œä¸ä¼šä½¿ç”¨è¿™ä¸ª registry</a>
<a name="137"><span class="lineNum">     137 </span>            :             // 2. å³ä½¿å…¶ä»–è¿›ç¨‹ shm_open äº†ï¼Œä¹Ÿä¼šåœ¨ç­‰å¾… magic æ—¶è¶…æ—¶</a>
<a name="138"><span class="lineNum">     138 </span><span class="lineNoCov">          0 :             shm_unlink(REGISTRY_SHM_NAME);</span></a>
<a name="139"><span class="lineNum">     139 </span><span class="lineNoCov">          0 :             return false;</span></a>
<a name="140"><span class="lineNum">     140 </span>            :         }</a>
<a name="141"><span class="lineNum">     141 </span>            : </a>
<a name="142"><span class="lineNum">     142 </span>            :         // ğŸ”§ éªŒè¯ ftruncate æ˜¯å¦æˆåŠŸè®¾ç½®äº†æ­£ç¡®çš„å¤§å°</a>
<a name="143"><span class="lineNum">     143 </span>            :         struct stat st;</a>
<a name="144"><span class="lineNum">     144 </span><span class="lineCov">        124 :         if (fstat(shm_fd_, &amp;st) == 0) {</span></a>
<a name="145"><span class="lineNum">     145 </span><span class="lineCov">        124 :             if (st.st_size != sizeof(RegistryRegion)) {</span></a>
<a name="146"><span class="lineNum">     146 </span><span class="lineNoCov">          0 :                 NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Registry size mismatch: expected &quot; +</span></a>
<a name="147"><span class="lineNum">     147 </span>            :                                                 std::to_string(sizeof(RegistryRegion)) + &quot;, got &quot; +</a>
<a name="148"><span class="lineNum">     148 </span>            :                                                 std::to_string(st.st_size));</a>
<a name="149"><span class="lineNum">     149 </span><span class="lineNoCov">          0 :                 close(shm_fd_);</span></a>
<a name="150"><span class="lineNum">     150 </span><span class="lineNoCov">          0 :                 shm_fd_ = -1;</span></a>
<a name="151"><span class="lineNum">     151 </span><span class="lineNoCov">          0 :                 return false;</span></a>
<a name="152"><span class="lineNum">     152 </span>            :             }</a>
<a name="153"><span class="lineNum">     153 </span>            :         }</a>
<a name="154"><span class="lineNum">     154 </span>            :     }</a>
<a name="155"><span class="lineNum">     155 </span>            : </a>
<a name="156"><span class="lineNum">     156 </span>            :     // Map memory</a>
<a name="157"><span class="lineNum">     157 </span><span class="lineCov">        236 :     shm_ptr_ = mmap(nullptr, sizeof(RegistryRegion), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd_, 0);</span></a>
<a name="158"><span class="lineNum">     158 </span><span class="lineCov">        236 :     if (shm_ptr_ == MAP_FAILED) {</span></a>
<a name="159"><span class="lineNum">     159 </span><span class="lineNoCov">          0 :         NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Failed to map memory: &quot; + std::string(strerror(errno)));</span></a>
<a name="160"><span class="lineNum">     160 </span><span class="lineNoCov">          0 :         close(shm_fd_);</span></a>
<a name="161"><span class="lineNum">     161 </span><span class="lineNoCov">          0 :         shm_fd_ = -1;</span></a>
<a name="162"><span class="lineNum">     162 </span>            :         // ğŸ”§ SAFE: åˆ›å»ºè€…åœ¨ mmap å¤±è´¥æ—¶å¯ä»¥åˆ é™¤</a>
<a name="163"><span class="lineNum">     163 </span>            :         // åŸå› ï¼šå…¶ä»–è¿›ç¨‹å³ä½¿ mmap æˆåŠŸäº†ï¼Œä¹Ÿä¼šåœ¨ç­‰å¾… magic æ—¶è¶…æ—¶</a>
<a name="164"><span class="lineNum">     164 </span>            :         // ç°åœ¨æœ‰äº†é”æœºåˆ¶ï¼Œæ‰€æœ‰è®¿é—®éƒ½åœ¨é”ä¿æŠ¤ä¸‹ï¼Œæ›´åŠ å®‰å…¨</a>
<a name="165"><span class="lineNum">     165 </span><span class="lineNoCov">          0 :         if (creating) {</span></a>
<a name="166"><span class="lineNum">     166 </span><span class="lineNoCov">          0 :             shm_unlink(REGISTRY_SHM_NAME);</span></a>
<a name="167"><span class="lineNum">     167 </span>            :         }</a>
<a name="168"><span class="lineNum">     168 </span><span class="lineNoCov">          0 :         return false;</span></a>
<a name="169"><span class="lineNum">     169 </span>            :     }</a>
<a name="170"><span class="lineNum">     170 </span>            : </a>
<a name="171"><span class="lineNum">     171 </span><span class="lineCov">        236 :     registry_ = static_cast&lt;RegistryRegion*&gt;(shm_ptr_);</span></a>
<a name="172"><span class="lineNum">     172 </span>            : </a>
<a name="173"><span class="lineNum">     173 </span><span class="lineCov">        236 :     if (creating) {</span></a>
<a name="174"><span class="lineNum">     174 </span>            :         // Initialize header (å…ˆåˆå§‹åŒ–å…¶ä»–å­—æ®µï¼Œæœ€åè®¾ç½®magicä½œä¸ºâ€œå°±ç»ªâ€æ ‡å¿—)</a>
<a name="175"><span class="lineNum">     175 </span>            : </a>
<a name="176"><span class="lineNum">     176 </span>            :         // ğŸ”§ CRITICAL: é¦–å…ˆåˆå§‹åŒ–è¿›ç¨‹é—´äº’æ–¥é”</a>
<a name="177"><span class="lineNum">     177 </span>            :         pthread_mutexattr_t mutex_attr;</a>
<a name="178"><span class="lineNum">     178 </span><span class="lineCov">        126 :         pthread_mutexattr_init(&amp;mutex_attr);</span></a>
<a name="179"><span class="lineNum">     179 </span><span class="lineCov">        126 :         pthread_mutexattr_setpshared(&amp;mutex_attr, PTHREAD_PROCESS_SHARED);  // è·¨è¿›ç¨‹å…±äº«</span></a>
<a name="180"><span class="lineNum">     180 </span><span class="lineCov">        126 :         pthread_mutexattr_setrobust(&amp;mutex_attr, PTHREAD_MUTEX_ROBUST);     // è¿›ç¨‹å´©æºƒåé”å¯æ¢å¤</span></a>
<a name="181"><span class="lineNum">     181 </span><span class="lineCov">        126 :         pthread_mutex_init(&amp;registry_-&gt;header.global_lock, &amp;mutex_attr);</span></a>
<a name="182"><span class="lineNum">     182 </span><span class="lineCov">        126 :         pthread_mutexattr_destroy(&amp;mutex_attr);</span></a>
<a name="183"><span class="lineNum">     183 </span>            : </a>
<a name="184"><span class="lineNum">     184 </span>            :         // ğŸ”§ ä½¿ç”¨ relaxed åˆå§‹åŒ–ï¼Œå› ä¸º magic è¿˜æœªè®¾ç½®ï¼Œå…¶ä»–è¿›ç¨‹çœ‹ä¸åˆ°</a>
<a name="185"><span class="lineNum">     185 </span><span class="lineCov">        126 :         registry_-&gt;header.version.store(VERSION, std::memory_order_relaxed);</span></a>
<a name="186"><span class="lineNum">     186 </span><span class="lineCov">        126 :         registry_-&gt;header.num_entries.store(0, std::memory_order_relaxed);</span></a>
<a name="187"><span class="lineNum">     187 </span><span class="lineCov">        126 :         registry_-&gt;header.capacity.store(MAX_REGISTRY_ENTRIES, std::memory_order_relaxed);</span></a>
<a name="188"><span class="lineNum">     188 </span>            : </a>
<a name="189"><span class="lineNum">     189 </span>            :         // ğŸ”§ åˆå§‹åŒ– ref_pids æ•°ç»„ï¼ˆä½†ä¸è®°å½•åˆ›å»ºè€… PIDï¼Œç­‰ magic è®¾ç½®åå†è®°å½•ï¼‰</a>
<a name="190"><span class="lineNum">     190 </span><span class="lineCov">      32382 :         for (size_t i = 0; i &lt; MAX_REGISTRY_ENTRIES; ++i) {</span></a>
<a name="191"><span class="lineNum">     191 </span><span class="lineCov">      32256 :             registry_-&gt;header.ref_pids[i].store(0, std::memory_order_relaxed);</span></a>
<a name="192"><span class="lineNum">     192 </span>            :         }</a>
<a name="193"><span class="lineNum">     193 </span>            : </a>
<a name="194"><span class="lineNum">     194 </span>            :         // ğŸ”§ ref_count åˆå§‹ä¸º 0ï¼Œç­‰ magic è®¾ç½®åå†é€’å¢</a>
<a name="195"><span class="lineNum">     195 </span><span class="lineCov">        126 :         registry_-&gt;header.ref_count.store(0, std::memory_order_relaxed);</span></a>
<a name="196"><span class="lineNum">     196 </span>            : </a>
<a name="197"><span class="lineNum">     197 </span>            :         // Initialize all entries</a>
<a name="198"><span class="lineNum">     198 </span><span class="lineCov">      32382 :         for (size_t i = 0; i &lt; MAX_REGISTRY_ENTRIES; ++i) {</span></a>
<a name="199"><span class="lineNum">     199 </span><span class="lineCov">      32256 :             registry_-&gt;entries[i].flags.store(0, std::memory_order_relaxed);</span></a>
<a name="200"><span class="lineNum">     200 </span>            :             // ğŸ”§ Initialize atomic string arrays to zero</a>
<a name="201"><span class="lineNum">     201 </span><span class="lineCov">     290304 :             for (int j = 0; j &lt; 8; ++j) {</span></a>
<a name="202"><span class="lineNum">     202 </span><span class="lineCov">     258048 :                 registry_-&gt;entries[i].node_id_atomic[j].store(0, std::memory_order_relaxed);</span></a>
<a name="203"><span class="lineNum">     203 </span><span class="lineCov">     258048 :                 registry_-&gt;entries[i].shm_name_atomic[j].store(0, std::memory_order_relaxed);</span></a>
<a name="204"><span class="lineNum">     204 </span>            :             }</a>
<a name="205"><span class="lineNum">     205 </span><span class="lineCov">      32256 :             registry_-&gt;entries[i].pid.store(0, std::memory_order_relaxed);</span></a>
<a name="206"><span class="lineNum">     206 </span><span class="lineCov">      32256 :             registry_-&gt;entries[i].last_heartbeat.store(0, std::memory_order_relaxed);</span></a>
<a name="207"><span class="lineNum">     207 </span>            :         }</a>
<a name="208"><span class="lineNum">     208 </span>            : </a>
<a name="209"><span class="lineNum">     209 </span>            :         // ğŸ”§ CRITICAL: åœ¨è®¾ç½®magicä¹‹å‰å…ˆè®°å½•ref_count=1ï¼Œé˜²æ­¢çª—å£æœŸè¢«è¯¯åˆ¤ä¸ºæ— äººä½¿ç”¨</a>
<a name="210"><span class="lineNum">     210 </span>            :         // ä½¿ç”¨relaxedå› ä¸ºmagicçš„releaseå±éšœä¼šåŒæ­¥æ‰€æœ‰æ•°æ®</a>
<a name="211"><span class="lineNum">     211 </span><span class="lineCov">        126 :         registry_-&gt;header.ref_pids[0].store(getpid(), std::memory_order_relaxed);</span></a>
<a name="212"><span class="lineNum">     212 </span><span class="lineCov">        126 :         registry_-&gt;header.ref_count.store(1, std::memory_order_relaxed);</span></a>
<a name="213"><span class="lineNum">     213 </span>            : </a>
<a name="214"><span class="lineNum">     214 </span>            :         // ğŸ”§ Memory barrierç¡®ä¿æ‰€æœ‰åˆå§‹åŒ–å®Œæˆåå†è®¾ç½®magic</a>
<a name="215"><span class="lineNum">     215 </span>            :         std::atomic_thread_fence(std::memory_order_release);</a>
<a name="216"><span class="lineNum">     216 </span><span class="lineCov">        126 :         registry_-&gt;header.magic.store(MAGIC, std::memory_order_release);</span></a>
<a name="217"><span class="lineNum">     217 </span>            : </a>
<a name="218"><span class="lineNum">     218 </span><span class="lineCov">        126 :         NEXUS_LOG_INFO(&quot;Registry&quot;, &quot;Created new registry at &quot; + std::string(REGISTRY_SHM_NAME));</span></a>
<a name="219"><span class="lineNum">     219 </span>            :     } else {</a>
<a name="220"><span class="lineNum">     220 </span>            :         // ğŸ”§ ç­‰å¾…å¹¶éªŒè¯registryåˆå§‹åŒ–å®Œæˆ</a>
<a name="221"><span class="lineNum">     221 </span><span class="lineCov">        110 :         bool valid = false;</span></a>
<a name="222"><span class="lineNum">     222 </span>            : </a>
<a name="223"><span class="lineNum">     223 </span><span class="lineCov">        710 :         for (int retry = 0; retry &lt; 100; ++retry) {</span></a>
<a name="224"><span class="lineNum">     224 </span>            :             // ğŸ”§ ç›´æ¥è¯»å– magicï¼Œacquire è¯­ä¹‰å·²ç»è¶³å¤Ÿï¼Œä¸éœ€è¦ fence</a>
<a name="225"><span class="lineNum">     225 </span><span class="lineCov">        704 :             uint32_t magic = registry_-&gt;header.magic.load(std::memory_order_acquire);</span></a>
<a name="226"><span class="lineNum">     226 </span><span class="lineCov">        704 :             if (magic == MAGIC) {</span></a>
<a name="227"><span class="lineNum">     227 </span>            :                 // ğŸ”§ CRITICAL: è·å–é”ä¿æŠ¤åç»­æ“ä½œ</a>
<a name="228"><span class="lineNum">     228 </span><span class="lineCov">        104 :                 int lock_result = pthread_mutex_lock(&amp;registry_-&gt;header.global_lock);</span></a>
<a name="229"><span class="lineNum">     229 </span>            : </a>
<a name="230"><span class="lineNum">     230 </span><span class="lineCov">        104 :                 if (lock_result == EOWNERDEAD) {</span></a>
<a name="231"><span class="lineNum">     231 </span>            :                     // ä¸Šä¸€ä¸ªæŒæœ‰é”çš„è¿›ç¨‹å´©æºƒï¼Œæ¢å¤é”çŠ¶æ€</a>
<a name="232"><span class="lineNum">     232 </span><span class="lineNoCov">          0 :                     NEXUS_LOG_WARN(&quot;Registry&quot;, &quot;Recovered mutex from dead process during initialization&quot;);</span></a>
<a name="233"><span class="lineNum">     233 </span><span class="lineNoCov">          0 :                     pthread_mutex_consistent(&amp;registry_-&gt;header.global_lock);</span></a>
<a name="234"><span class="lineNum">     234 </span><span class="lineNoCov">          0 :                     lock_result = 0;</span></a>
<a name="235"><span class="lineNum">     235 </span>            :                 }</a>
<a name="236"><span class="lineNum">     236 </span>            : </a>
<a name="237"><span class="lineNum">     237 </span><span class="lineCov">        104 :                 if (lock_result == 0) {</span></a>
<a name="238"><span class="lineNum">     238 </span>            :                     // å†æ¬¡æ£€æŸ¥ magicï¼ˆåŒé‡æ£€æŸ¥ï¼‰</a>
<a name="239"><span class="lineNum">     239 </span><span class="lineCov">        208 :                     if (registry_-&gt;header.magic.load(std::memory_order_acquire) == MAGIC) {</span></a>
<a name="240"><span class="lineNum">     240 </span><span class="lineCov">        104 :                         valid = true;</span></a>
<a name="241"><span class="lineNum">     241 </span>            : </a>
<a name="242"><span class="lineNum">     242 </span>            :                         // ğŸ”§ ä¼˜åŒ–ï¼šå…ˆè®°å½• PID å†é€’å¢ ref_countï¼Œé˜²æ­¢å´©æºƒæ—¶ä¸ä¸€è‡´</a>
<a name="243"><span class="lineNum">     243 </span><span class="lineCov">        104 :                         pid_t my_pid = getpid();</span></a>
<a name="244"><span class="lineNum">     244 </span><span class="lineCov">        104 :                         bool pid_recorded = false;</span></a>
<a name="245"><span class="lineNum">     245 </span>            : </a>
<a name="246"><span class="lineNum">     246 </span>            :                         // åœ¨ ref_pids æ•°ç»„ä¸­æ‰¾ç©ºä½è®°å½• PID</a>
<a name="247"><span class="lineNum">     247 </span><span class="lineCov">       1390 :                         for (size_t i = 0; i &lt; MAX_REGISTRY_ENTRIES; ++i) {</span></a>
<a name="248"><span class="lineNum">     248 </span><span class="lineCov">       1390 :                             uint32_t expected = 0;</span></a>
<a name="249"><span class="lineNum">     249 </span><span class="lineCov">       2780 :                             if (registry_-&gt;header.ref_pids[i].compare_exchange_strong(expected, my_pid,</span></a>
<a name="250"><span class="lineNum">     250 </span>            :                                                                                       std::memory_order_release)) {</a>
<a name="251"><span class="lineNum">     251 </span><span class="lineCov">        104 :                                 pid_recorded = true;</span></a>
<a name="252"><span class="lineNum">     252 </span><span class="lineCov">        104 :                                 break;</span></a>
<a name="253"><span class="lineNum">     253 </span>            :                             }</a>
<a name="254"><span class="lineNum">     254 </span>            :                         }</a>
<a name="255"><span class="lineNum">     255 </span>            : </a>
<a name="256"><span class="lineNum">     256 </span>            :                         // åªæœ‰åœ¨ PID è®°å½•æˆåŠŸåæ‰é€’å¢ ref_count</a>
<a name="257"><span class="lineNum">     257 </span><span class="lineCov">        104 :                         if (pid_recorded) {</span></a>
<a name="258"><span class="lineNum">     258 </span><span class="lineCov">        104 :                             registry_-&gt;header.ref_count.fetch_add(1, std::memory_order_release);</span></a>
<a name="259"><span class="lineNum">     259 </span>            :                         } else {</a>
<a name="260"><span class="lineNum">     260 </span><span class="lineNoCov">          0 :                             NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Failed to record PID: ref_pids array full (&quot; +</span></a>
<a name="261"><span class="lineNum">     261 </span>            :                                                             std::to_string(MAX_REGISTRY_ENTRIES) +</a>
<a name="262"><span class="lineNum">     262 </span>            :                                                             &quot; processes already using registry)&quot;);</a>
<a name="263"><span class="lineNum">     263 </span><span class="lineNoCov">          0 :                             valid = false;</span></a>
<a name="264"><span class="lineNum">     264 </span>            :                             // éœ€è¦æ¸…ç†å·²åˆ†é…çš„èµ„æº</a>
<a name="265"><span class="lineNum">     265 </span>            :                         }</a>
<a name="266"><span class="lineNum">     266 </span>            :                     }</a>
<a name="267"><span class="lineNum">     267 </span>            : </a>
<a name="268"><span class="lineNum">     268 </span><span class="lineCov">        104 :                     pthread_mutex_unlock(&amp;registry_-&gt;header.global_lock);</span></a>
<a name="269"><span class="lineNum">     269 </span>            : </a>
<a name="270"><span class="lineNum">     270 </span><span class="lineCov">        104 :                     if (valid)</span></a>
<a name="271"><span class="lineNum">     271 </span><span class="lineCov">        104 :                         break;</span></a>
<a name="272"><span class="lineNum">     272 </span>            :                 }</a>
<a name="273"><span class="lineNum">     273 </span>            :             }</a>
<a name="274"><span class="lineNum">     274 </span>            : </a>
<a name="275"><span class="lineNum">     275 </span>            :             // Registryæ­£åœ¨åˆå§‹åŒ–ä¸­ï¼Œç­‰å¾…ä¸€å°æ®µæ—¶é—´</a>
<a name="276"><span class="lineNum">     276 </span><span class="lineCov">        600 :             std::this_thread::sleep_for(std::chrono::milliseconds(10));</span></a>
<a name="277"><span class="lineNum">     277 </span>            :         }</a>
<a name="278"><span class="lineNum">     278 </span>            : </a>
<a name="279"><span class="lineNum">     279 </span><span class="lineCov">        110 :         if (!valid) {</span></a>
<a name="280"><span class="lineNum">     280 </span><span class="lineCov">          6 :             NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Registry initialization timeout - magic number not set after 1000ms&quot;);</span></a>
<a name="281"><span class="lineNum">     281 </span>            : </a>
<a name="282"><span class="lineNum">     282 </span>            :             // ğŸ”§ CRITICAL: æ£€æŸ¥æ˜¯å¦æ˜¯æŸåçš„ registryï¼ˆåˆ›å»ºè€…å´©æºƒæˆ–åˆå§‹åŒ–å¤±è´¥ï¼‰</a>
<a name="283"><span class="lineNum">     283 </span>            :             // ğŸ”§ è¯»å–å½“å‰ magic å€¼æ¥åˆ¤æ–­ï¼ˆatomic load ä¸ä¼šæŠ›å¼‚å¸¸ï¼‰</a>
<a name="284"><span class="lineNum">     284 </span><span class="lineCov">          6 :             uint32_t current_magic = registry_-&gt;header.magic.load(std::memory_order_acquire);</span></a>
<a name="285"><span class="lineNum">     285 </span>            : </a>
<a name="286"><span class="lineNum">     286 </span>            :             // æ¸…ç†å½“å‰æ˜ å°„</a>
<a name="287"><span class="lineNum">     287 </span><span class="lineCov">          6 :             registry_ = nullptr;</span></a>
<a name="288"><span class="lineNum">     288 </span><span class="lineCov">          6 :             if (shm_ptr_ &amp;&amp; shm_ptr_ != MAP_FAILED) {</span></a>
<a name="289"><span class="lineNum">     289 </span><span class="lineCov">          6 :                 munmap(shm_ptr_, sizeof(RegistryRegion));</span></a>
<a name="290"><span class="lineNum">     290 </span><span class="lineCov">          6 :                 shm_ptr_ = nullptr;</span></a>
<a name="291"><span class="lineNum">     291 </span>            :             }</a>
<a name="292"><span class="lineNum">     292 </span><span class="lineCov">          6 :             close(shm_fd_);</span></a>
<a name="293"><span class="lineNum">     293 </span><span class="lineCov">          6 :             shm_fd_ = -1;</span></a>
<a name="294"><span class="lineNum">     294 </span>            : </a>
<a name="295"><span class="lineNum">     295 </span>            :             // ğŸ”§ å¦‚æœ magic=0ï¼Œè¯´æ˜ registry è¢«åˆ›å»ºä½†æœªåˆå§‹åŒ–å®Œæˆ</a>
<a name="296"><span class="lineNum">     296 </span><span class="lineCov">          6 :             if (current_magic == 0) {</span></a>
<a name="297"><span class="lineNum">     297 </span><span class="lineCov">          4 :                 NEXUS_LOG_WARN(&quot;Registry&quot;, &quot;Detected corrupted registry (magic=0), may need manual cleanup or restart&quot;);</span></a>
<a name="298"><span class="lineNum">     298 </span>            :             }</a>
<a name="299"><span class="lineNum">     299 </span>            : </a>
<a name="300"><span class="lineNum">     300 </span><span class="lineCov">          6 :             return false;</span></a>
<a name="301"><span class="lineNum">     301 </span>            :         }</a>
<a name="302"><span class="lineNum">     302 </span>            : </a>
<a name="303"><span class="lineNum">     303 </span><span class="lineCov">        208 :         NEXUS_LOG_INFO(&quot;Registry&quot;, &quot;Opened existing registry with &quot; +</span></a>
<a name="304"><span class="lineNum">     304 </span>            :                                        std::to_string(registry_-&gt;header.num_entries.load()) + &quot; entries&quot;);</a>
<a name="305"><span class="lineNum">     305 </span>            :     }</a>
<a name="306"><span class="lineNum">     306 </span>            : </a>
<a name="307"><span class="lineNum">     307 </span><span class="lineCov">        230 :     initialized_ = true;</span></a>
<a name="308"><span class="lineNum">     308 </span><span class="lineCov">        230 :     return true;</span></a>
<a name="309"><span class="lineNum">     309 </span>            : }</a>
<a name="310"><span class="lineNum">     310 </span>            : </a>
<a name="311"><span class="lineNum">     311 </span><span class="lineCov">        951 : bool SharedMemoryRegistry::registerNode(const std::string&amp; node_id, const std::string&amp; shm_name) {</span></a>
<a name="312"><span class="lineNum">     312 </span><span class="lineCov">        951 :     if (!initialized_) {</span></a>
<a name="313"><span class="lineNum">     313 </span><span class="lineNoCov">          0 :         return false;</span></a>
<a name="314"><span class="lineNum">     314 </span>            :     }</a>
<a name="315"><span class="lineNum">     315 </span>            : </a>
<a name="316"><span class="lineNum">     316 </span><span class="lineCov">        951 :     if (node_id.empty() || shm_name.empty()) {</span></a>
<a name="317"><span class="lineNum">     317 </span><span class="lineCov">          4 :         return false;</span></a>
<a name="318"><span class="lineNum">     318 </span>            :     }</a>
<a name="319"><span class="lineNum">     319 </span>            : </a>
<a name="320"><span class="lineNum">     320 </span><span class="lineCov">        947 :     if (node_id.size() &gt;= NODE_ID_SIZE || shm_name.size() &gt;= SHM_NAME_SIZE) {</span></a>
<a name="321"><span class="lineNum">     321 </span><span class="lineCov">          4 :         NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Node ID or shm name too long&quot;);</span></a>
<a name="322"><span class="lineNum">     322 </span><span class="lineCov">          4 :         return false;</span></a>
<a name="323"><span class="lineNum">     323 </span>            :     }</a>
<a name="324"><span class="lineNum">     324 </span>            : </a>
<a name="325"><span class="lineNum">     325 </span>            :     // ğŸ”§ CRITICAL: ä½¿ç”¨é”ä¿æŠ¤æ•´ä¸ªæ³¨å†Œæ“ä½œ</a>
<a name="326"><span class="lineNum">     326 </span><span class="lineCov">        943 :     RegistryLock lock(&amp;registry_-&gt;header.global_lock);</span></a>
<a name="327"><span class="lineNum">     327 </span><span class="lineCov">        943 :     if (!lock.isLocked()) {</span></a>
<a name="328"><span class="lineNum">     328 </span><span class="lineNoCov">          0 :         NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Failed to acquire lock for registerNode&quot;);</span></a>
<a name="329"><span class="lineNum">     329 </span><span class="lineNoCov">          0 :         return false;</span></a>
<a name="330"><span class="lineNum">     330 </span>            :     }</a>
<a name="331"><span class="lineNum">     331 </span>            : </a>
<a name="332"><span class="lineNum">     332 </span>            :     // Check if already registered</a>
<a name="333"><span class="lineNum">     333 </span><span class="lineCov">        943 :     int existing_idx = findEntryIndex(node_id);</span></a>
<a name="334"><span class="lineNum">     334 </span><span class="lineCov">        943 :     if (existing_idx &gt;= 0) {</span></a>
<a name="335"><span class="lineNum">     335 </span>            :         // Update existing entry</a>
<a name="336"><span class="lineNum">     336 </span><span class="lineCov">          3 :         RegistryEntry&amp; entry = registry_-&gt;entries[existing_idx];</span></a>
<a name="337"><span class="lineNum">     337 </span>            : </a>
<a name="338"><span class="lineNum">     338 </span>            :         // ğŸ”§ Write using atomic operations for cross-process safety</a>
<a name="339"><span class="lineNum">     339 </span><span class="lineCov">          3 :         writeAtomicString(entry.shm_name_atomic, shm_name, SHM_NAME_SIZE);</span></a>
<a name="340"><span class="lineNum">     340 </span><span class="lineCov">          3 :         entry.pid.store(getpid(), std::memory_order_seq_cst);</span></a>
<a name="341"><span class="lineNum">     341 </span><span class="lineCov">          3 :         uint64_t update_ts = getCurrentTimeMs();</span></a>
<a name="342"><span class="lineNum">     342 </span><span class="lineCov">          3 :         entry.last_heartbeat.store(update_ts, std::memory_order_seq_cst);</span></a>
<a name="343"><span class="lineNum">     343 </span><span class="lineCov">          3 :         NEXUS_LOG_INFO(&quot;Registry&quot;, &quot;[TIMESTAMP] registerNode (update): &quot; + node_id +</span></a>
<a name="344"><span class="lineNum">     344 </span>            :                                        &quot; updated_hb=&quot; + std::to_string(update_ts) + &quot;ms&quot;);</a>
<a name="345"><span class="lineNum">     345 </span>            : </a>
<a name="346"><span class="lineNum">     346 </span>            :         // ğŸ”§ Increment version to detect ABA problem</a>
<a name="347"><span class="lineNum">     347 </span><span class="lineCov">          3 :         entry.version.fetch_add(1, std::memory_order_release);</span></a>
<a name="348"><span class="lineNum">     348 </span>            : </a>
<a name="349"><span class="lineNum">     349 </span>            :         // ğŸ”§ Finally set flags to indicate entry is valid</a>
<a name="350"><span class="lineNum">     350 </span><span class="lineCov">          3 :         entry.flags.store(0x3, std::memory_order_seq_cst);  // valid | active</span></a>
<a name="351"><span class="lineNum">     351 </span>            : </a>
<a name="352"><span class="lineNum">     352 </span><span class="lineCov">          3 :         NEXUS_LOG_INFO(&quot;Registry&quot;, &quot;Updated node: &quot; + node_id + &quot; -&gt; &quot; + shm_name);</span></a>
<a name="353"><span class="lineNum">     353 </span><span class="lineCov">          3 :         return true;</span></a>
<a name="354"><span class="lineNum">     354 </span>            :     }</a>
<a name="355"><span class="lineNum">     355 </span>            : </a>
<a name="356"><span class="lineNum">     356 </span>            :     // ğŸ”§ CRITICAL: Atomically claim a free entry using CAS to prevent race conditions</a>
<a name="357"><span class="lineNum">     357 </span>            :     // Multiple processes may call registerNode() concurrently during startup</a>
<a name="358"><span class="lineNum">     358 </span>            :     // Without atomic allocation, they could get the same index and overwrite each other</a>
<a name="359"><span class="lineNum">     359 </span><span class="lineCov">        940 :     int idx = -1;</span></a>
<a name="360"><span class="lineNum">     360 </span><span class="lineCov">      76951 :     for (size_t i = 0; i &lt; MAX_REGISTRY_ENTRIES; ++i) {</span></a>
<a name="361"><span class="lineNum">     361 </span><span class="lineCov">      76949 :         uint32_t expected = 0;   // Free entry (flags == 0)</span></a>
<a name="362"><span class="lineNum">     362 </span><span class="lineCov">      76949 :         uint32_t desired = 0x1;  // Claim it (valid bit set, but not active yet)</span></a>
<a name="363"><span class="lineNum">     363 </span>            : </a>
<a name="364"><span class="lineNum">     364 </span>            :         // Try to atomically claim this entry</a>
<a name="365"><span class="lineNum">     365 </span><span class="lineCov">     153898 :         if (registry_-&gt;entries[i].flags.compare_exchange_strong(expected, desired, std::memory_order_acq_rel)) {</span></a>
<a name="366"><span class="lineNum">     366 </span><span class="lineCov">        938 :             idx = static_cast&lt;int&gt;(i);</span></a>
<a name="367"><span class="lineNum">     367 </span><span class="lineCov">        938 :             break;</span></a>
<a name="368"><span class="lineNum">     368 </span>            :         }</a>
<a name="369"><span class="lineNum">     369 </span>            :     }</a>
<a name="370"><span class="lineNum">     370 </span>            : </a>
<a name="371"><span class="lineNum">     371 </span><span class="lineCov">        940 :     if (idx &lt; 0) {</span></a>
<a name="372"><span class="lineNum">     372 </span><span class="lineCov">          2 :         NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Registry full (max &quot; + std::to_string(MAX_REGISTRY_ENTRIES) + &quot; nodes)&quot;);</span></a>
<a name="373"><span class="lineNum">     373 </span><span class="lineCov">          2 :         return false;</span></a>
<a name="374"><span class="lineNum">     374 </span>            :     }</a>
<a name="375"><span class="lineNum">     375 </span>            : </a>
<a name="376"><span class="lineNum">     376 </span>            :     // Register new node (we now have exclusive ownership of this entry)</a>
<a name="377"><span class="lineNum">     377 </span><span class="lineCov">        938 :     RegistryEntry&amp; entry = registry_-&gt;entries[idx];</span></a>
<a name="378"><span class="lineNum">     378 </span>            : </a>
<a name="379"><span class="lineNum">     379 </span>            :     // ğŸ”§ CRITICAL: Write all fields using atomic operations for cross-process safety</a>
<a name="380"><span class="lineNum">     380 </span><span class="lineCov">        938 :     writeAtomicString(entry.node_id_atomic, node_id, NODE_ID_SIZE);</span></a>
<a name="381"><span class="lineNum">     381 </span><span class="lineCov">        938 :     writeAtomicString(entry.shm_name_atomic, shm_name, SHM_NAME_SIZE);</span></a>
<a name="382"><span class="lineNum">     382 </span><span class="lineCov">        938 :     entry.pid.store(getpid(), std::memory_order_seq_cst);</span></a>
<a name="383"><span class="lineNum">     383 </span><span class="lineCov">        938 :     uint64_t init_ts = getCurrentTimeMs();</span></a>
<a name="384"><span class="lineNum">     384 </span><span class="lineCov">        938 :     entry.last_heartbeat.store(init_ts, std::memory_order_seq_cst);</span></a>
<a name="385"><span class="lineNum">     385 </span><span class="lineCov">        938 :     NEXUS_LOG_INFO(&quot;Registry&quot;,</span></a>
<a name="386"><span class="lineNum">     386 </span>            :                    &quot;[TIMESTAMP] registerNode (new): &quot; + node_id + &quot; initial_hb=&quot; + std::to_string(init_ts) + &quot;ms&quot;);</a>
<a name="387"><span class="lineNum">     387 </span>            : </a>
<a name="388"><span class="lineNum">     388 </span>            :     // ğŸ”§ Initialize version (use fetch_add for atomicity)</a>
<a name="389"><span class="lineNum">     389 </span><span class="lineCov">        938 :     entry.version.fetch_add(1, std::memory_order_release);</span></a>
<a name="390"><span class="lineNum">     390 </span>            : </a>
<a name="391"><span class="lineNum">     391 </span>            :     // ğŸ”§ CRITICAL: Set flags last to publish the entry atomically</a>
<a name="392"><span class="lineNum">     392 </span><span class="lineCov">        938 :     entry.flags.store(0x3, std::memory_order_seq_cst);  // valid | active</span></a>
<a name="393"><span class="lineNum">     393 </span>            : </a>
<a name="394"><span class="lineNum">     394 </span>            :     // ğŸ”§ Update num_entries with release so other processes see the new entry</a>
<a name="395"><span class="lineNum">     395 </span><span class="lineCov">        938 :     registry_-&gt;header.num_entries.fetch_add(1, std::memory_order_release);</span></a>
<a name="396"><span class="lineNum">     396 </span>            : </a>
<a name="397"><span class="lineNum">     397 </span><span class="lineCov">       1876 :     NEXUS_LOG_INFO(&quot;Registry&quot;, &quot;Registered node: &quot; + node_id + &quot; -&gt; &quot; + shm_name + &quot; (total: &quot; +</span></a>
<a name="398"><span class="lineNum">     398 </span>            :                                    std::to_string(registry_-&gt;header.num_entries.load(std::memory_order_acquire)) + &quot;)&quot;);</a>
<a name="399"><span class="lineNum">     399 </span>            : </a>
<a name="400"><span class="lineNum">     400 </span><span class="lineCov">        938 :     return true;</span></a>
<a name="401"><span class="lineNum">     401 </span><span class="lineCov">        943 : }</span></a>
<a name="402"><span class="lineNum">     402 </span>            : </a>
<a name="403"><span class="lineNum">     403 </span><span class="lineCov">        223 : bool SharedMemoryRegistry::unregisterNode(const std::string&amp; node_id) {</span></a>
<a name="404"><span class="lineNum">     404 </span><span class="lineCov">        223 :     if (!initialized_) {</span></a>
<a name="405"><span class="lineNum">     405 </span><span class="lineNoCov">          0 :         return false;</span></a>
<a name="406"><span class="lineNum">     406 </span>            :     }</a>
<a name="407"><span class="lineNum">     407 </span>            : </a>
<a name="408"><span class="lineNum">     408 </span>            :     // ğŸ”§ CRITICAL: ä½¿ç”¨é”ä¿æŠ¤æ³¨é”€æ“ä½œ</a>
<a name="409"><span class="lineNum">     409 </span><span class="lineCov">        223 :     RegistryLock lock(&amp;registry_-&gt;header.global_lock);</span></a>
<a name="410"><span class="lineNum">     410 </span><span class="lineCov">        223 :     if (!lock.isLocked()) {</span></a>
<a name="411"><span class="lineNum">     411 </span><span class="lineNoCov">          0 :         NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Failed to acquire lock for unregisterNode&quot;);</span></a>
<a name="412"><span class="lineNum">     412 </span><span class="lineNoCov">          0 :         return false;</span></a>
<a name="413"><span class="lineNum">     413 </span>            :     }</a>
<a name="414"><span class="lineNum">     414 </span>            : </a>
<a name="415"><span class="lineNum">     415 </span><span class="lineCov">        223 :     int idx = findEntryIndex(node_id);</span></a>
<a name="416"><span class="lineNum">     416 </span><span class="lineCov">        223 :     if (idx &lt; 0) {</span></a>
<a name="417"><span class="lineNum">     417 </span><span class="lineCov">          5 :         return false;</span></a>
<a name="418"><span class="lineNum">     418 </span>            :     }</a>
<a name="419"><span class="lineNum">     419 </span>            : </a>
<a name="420"><span class="lineNum">     420 </span>            :     // Clear entry</a>
<a name="421"><span class="lineNum">     421 </span><span class="lineCov">        218 :     RegistryEntry&amp; entry = registry_-&gt;entries[idx];</span></a>
<a name="422"><span class="lineNum">     422 </span>            : </a>
<a name="423"><span class="lineNum">     423 </span>            :     // ğŸ”§ CRITICAL: Decrement with release to ensure visibility</a>
<a name="424"><span class="lineNum">     424 </span><span class="lineCov">        218 :     registry_-&gt;header.num_entries.fetch_sub(1, std::memory_order_release);</span></a>
<a name="425"><span class="lineNum">     425 </span>            : </a>
<a name="426"><span class="lineNum">     426 </span>            :     // ğŸ”§ Clear flags with seq_cst to prevent other processes from seeing this entry</a>
<a name="427"><span class="lineNum">     427 </span><span class="lineCov">        218 :     entry.flags.store(0, std::memory_order_seq_cst);</span></a>
<a name="428"><span class="lineNum">     428 </span>            : </a>
<a name="429"><span class="lineNum">     429 </span>            :     // ğŸ”§ Increment version to invalidate any cached references (ABA protection)</a>
<a name="430"><span class="lineNum">     430 </span><span class="lineCov">        218 :     entry.version.fetch_add(1, std::memory_order_release);</span></a>
<a name="431"><span class="lineNum">     431 </span>            : </a>
<a name="432"><span class="lineNum">     432 </span>            :     // ğŸ”§ Now safe to clear other atomic fields (no one can see this entry anymore)</a>
<a name="433"><span class="lineNum">     433 </span>            :     // Use release to ensure visibility of the clear operation</a>
<a name="434"><span class="lineNum">     434 </span><span class="lineCov">       1962 :     for (int j = 0; j &lt; 8; ++j) {</span></a>
<a name="435"><span class="lineNum">     435 </span><span class="lineCov">       1744 :         entry.node_id_atomic[j].store(0, std::memory_order_release);</span></a>
<a name="436"><span class="lineNum">     436 </span><span class="lineCov">       1744 :         entry.shm_name_atomic[j].store(0, std::memory_order_release);</span></a>
<a name="437"><span class="lineNum">     437 </span>            :     }</a>
<a name="438"><span class="lineNum">     438 </span><span class="lineCov">        218 :     entry.pid.store(0, std::memory_order_release);</span></a>
<a name="439"><span class="lineNum">     439 </span><span class="lineCov">        218 :     entry.last_heartbeat.store(0, std::memory_order_release);</span></a>
<a name="440"><span class="lineNum">     440 </span>            : </a>
<a name="441"><span class="lineNum">     441 </span><span class="lineCov">        436 :     NEXUS_LOG_INFO(&quot;Registry&quot;, &quot;Unregistered node: &quot; + node_id +</span></a>
<a name="442"><span class="lineNum">     442 </span>            :                                    &quot; (remaining: &quot; + std::to_string(registry_-&gt;header.num_entries.load()) + &quot;)&quot;);</a>
<a name="443"><span class="lineNum">     443 </span>            : </a>
<a name="444"><span class="lineNum">     444 </span><span class="lineCov">        218 :     return true;</span></a>
<a name="445"><span class="lineNum">     445 </span><span class="lineCov">        223 : }</span></a>
<a name="446"><span class="lineNum">     446 </span>            : </a>
<a name="447"><span class="lineNum">     447 </span><span class="lineCov">        362 : bool SharedMemoryRegistry::updateHeartbeat(const std::string&amp; node_id) {</span></a>
<a name="448"><span class="lineNum">     448 </span><span class="lineCov">        362 :     if (!initialized_) {</span></a>
<a name="449"><span class="lineNum">     449 </span><span class="lineNoCov">          0 :         return false;</span></a>
<a name="450"><span class="lineNum">     450 </span>            :     }</a>
<a name="451"><span class="lineNum">     451 </span>            : </a>
<a name="452"><span class="lineNum">     452 </span>            :     // ğŸ”§ CRITICAL: å¿ƒè·³æ›´æ–°å¿…é¡»åœ¨é”ä¿æŠ¤ä¸‹å®Œæˆï¼Œé˜²æ­¢èŠ‚ç‚¹åœ¨æ›´æ–°å‰è¢«æ³¨é”€/é‡ç”¨</a>
<a name="453"><span class="lineNum">     453 </span><span class="lineCov">        362 :     RegistryLock lock(&amp;registry_-&gt;header.global_lock, 1000);  // 1ç§’è¶…æ—¶</span></a>
<a name="454"><span class="lineNum">     454 </span><span class="lineCov">        362 :     if (!lock.isLocked()) {</span></a>
<a name="455"><span class="lineNum">     455 </span><span class="lineCov">          2 :         NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Failed to acquire lock for updateHeartbeat&quot;);</span></a>
<a name="456"><span class="lineNum">     456 </span><span class="lineCov">          2 :         return false;</span></a>
<a name="457"><span class="lineNum">     457 </span>            :     }</a>
<a name="458"><span class="lineNum">     458 </span>            : </a>
<a name="459"><span class="lineNum">     459 </span><span class="lineCov">        360 :     int idx = findEntryIndex(node_id);</span></a>
<a name="460"><span class="lineNum">     460 </span><span class="lineCov">        360 :     if (idx &lt; 0) {</span></a>
<a name="461"><span class="lineNum">     461 </span><span class="lineCov">          5 :         return false;</span></a>
<a name="462"><span class="lineNum">     462 </span>            :     }</a>
<a name="463"><span class="lineNum">     463 </span>            : </a>
<a name="464"><span class="lineNum">     464 </span>            :     // ğŸ”§ éªŒè¯ç‰ˆæœ¬å·é˜²æ­¢ABAé—®é¢˜</a>
<a name="465"><span class="lineNum">     465 </span><span class="lineCov">        355 :     RegistryEntry&amp; entry = registry_-&gt;entries[idx];</span></a>
<a name="466"><span class="lineNum">     466 </span><span class="lineCov">        355 :     uint32_t version_before = entry.version.load(std::memory_order_acquire);</span></a>
<a name="467"><span class="lineNum">     467 </span>            : </a>
<a name="468"><span class="lineNum">     468 </span>            :     // æ›´æ–°å¿ƒè·³æ—¶é—´æˆ³</a>
<a name="469"><span class="lineNum">     469 </span><span class="lineCov">        355 :     uint64_t hb_ts = getCurrentTimeMs();</span></a>
<a name="470"><span class="lineNum">     470 </span><span class="lineCov">        355 :     entry.last_heartbeat.store(hb_ts, std::memory_order_release);</span></a>
<a name="471"><span class="lineNum">     471 </span>            : </a>
<a name="472"><span class="lineNum">     472 </span>            :     // å†æ¬¡éªŒè¯ç‰ˆæœ¬å·</a>
<a name="473"><span class="lineNum">     473 </span><span class="lineCov">        355 :     uint32_t version_after = entry.version.load(std::memory_order_acquire);</span></a>
<a name="474"><span class="lineNum">     474 </span><span class="lineCov">        355 :     if (version_before != version_after) {</span></a>
<a name="475"><span class="lineNum">     475 </span>            :         // Entry åœ¨æ›´æ–°è¿‡ç¨‹ä¸­è¢«é‡ç”¨</a>
<a name="476"><span class="lineNum">     476 </span><span class="lineNoCov">          0 :         return false;</span></a>
<a name="477"><span class="lineNum">     477 </span>            :     }</a>
<a name="478"><span class="lineNum">     478 </span>            : </a>
<a name="479"><span class="lineNum">     479 </span><span class="lineCov">        355 :     return true;</span></a>
<a name="480"><span class="lineNum">     480 </span><span class="lineCov">        362 : }</span></a>
<a name="481"><span class="lineNum">     481 </span>            : </a>
<a name="482"><span class="lineNum">     482 </span><span class="lineCov">      11258 : std::vector&lt;NodeInfo&gt; SharedMemoryRegistry::getAllNodes() const {</span></a>
<a name="483"><span class="lineNum">     483 </span><span class="lineCov">      11258 :     std::vector&lt;NodeInfo&gt; nodes;</span></a>
<a name="484"><span class="lineNum">     484 </span>            : </a>
<a name="485"><span class="lineNum">     485 </span><span class="lineCov">      11258 :     if (!initialized_) {</span></a>
<a name="486"><span class="lineNum">     486 </span><span class="lineNoCov">          0 :         return nodes;</span></a>
<a name="487"><span class="lineNum">     487 </span>            :     }</a>
<a name="488"><span class="lineNum">     488 </span>            : </a>
<a name="489"><span class="lineNum">     489 </span>            :     // ğŸ”§ CRITICAL: ä½¿ç”¨é”ä¿æŠ¤éå†æ“ä½œ</a>
<a name="490"><span class="lineNum">     490 </span><span class="lineCov">      11258 :     RegistryLock lock(const_cast&lt;pthread_mutex_t*&gt;(&amp;registry_-&gt;header.global_lock));</span></a>
<a name="491"><span class="lineNum">     491 </span><span class="lineCov">      11258 :     if (!lock.isLocked()) {</span></a>
<a name="492"><span class="lineNum">     492 </span><span class="lineNoCov">          0 :         NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Failed to acquire lock for getAllNodes&quot;);</span></a>
<a name="493"><span class="lineNum">     493 </span><span class="lineNoCov">          0 :         return nodes;</span></a>
<a name="494"><span class="lineNum">     494 </span>            :     }</a>
<a name="495"><span class="lineNum">     495 </span>            : </a>
<a name="496"><span class="lineNum">     496 </span><span class="lineCov">    2893306 :     for (size_t i = 0; i &lt; MAX_REGISTRY_ENTRIES; ++i) {</span></a>
<a name="497"><span class="lineNum">     497 </span><span class="lineCov">    2882048 :         const RegistryEntry&amp; entry = registry_-&gt;entries[i];</span></a>
<a name="498"><span class="lineNum">     498 </span>            :         // ğŸ”§ Use seq_cst for shared memory visibility</a>
<a name="499"><span class="lineNum">     499 </span><span class="lineCov">    2882048 :         uint32_t flags = entry.flags.load(std::memory_order_seq_cst);</span></a>
<a name="500"><span class="lineNum">     500 </span>            : </a>
<a name="501"><span class="lineNum">     501 </span><span class="lineCov">    2882048 :         if ((flags &amp; 0x1) == 0) {  // Not valid</span></a>
<a name="502"><span class="lineNum">     502 </span><span class="lineCov">    2850041 :             continue;</span></a>
<a name="503"><span class="lineNum">     503 </span>            :         }</a>
<a name="504"><span class="lineNum">     504 </span>            : </a>
<a name="505"><span class="lineNum">     505 </span>            :         // ğŸ”§ Read all fields atomically</a>
<a name="506"><span class="lineNum">     506 </span><span class="lineCov">      32007 :         NodeInfo info;</span></a>
<a name="507"><span class="lineNum">     507 </span><span class="lineCov">      32007 :         info.node_id = readAtomicString(entry.node_id_atomic, NODE_ID_SIZE);</span></a>
<a name="508"><span class="lineNum">     508 </span><span class="lineCov">      32007 :         info.shm_name = readAtomicString(entry.shm_name_atomic, SHM_NAME_SIZE);</span></a>
<a name="509"><span class="lineNum">     509 </span><span class="lineCov">      32007 :         info.pid = entry.pid.load(std::memory_order_seq_cst);</span></a>
<a name="510"><span class="lineNum">     510 </span><span class="lineCov">      32007 :         info.last_heartbeat = entry.last_heartbeat.load(std::memory_order_seq_cst);</span></a>
<a name="511"><span class="lineNum">     511 </span><span class="lineCov">      32007 :         info.active = (flags &amp; 0x2) != 0;</span></a>
<a name="512"><span class="lineNum">     512 </span>            : </a>
<a name="513"><span class="lineNum">     513 </span><span class="lineCov">      32007 :         nodes.push_back(info);</span></a>
<a name="514"><span class="lineNum">     514 </span><span class="lineCov">      32007 :     }</span></a>
<a name="515"><span class="lineNum">     515 </span>            : </a>
<a name="516"><span class="lineNum">     516 </span><span class="lineCov">      11258 :     return nodes;</span></a>
<a name="517"><span class="lineNum">     517 </span><span class="lineCov">      11258 : }</span></a>
<a name="518"><span class="lineNum">     518 </span>            : </a>
<a name="519"><span class="lineNum">     519 </span><span class="lineCov">        202 : bool SharedMemoryRegistry::findNode(const std::string&amp; node_id, NodeInfo&amp; info) const {</span></a>
<a name="520"><span class="lineNum">     520 </span><span class="lineCov">        202 :     if (!initialized_) {</span></a>
<a name="521"><span class="lineNum">     521 </span><span class="lineNoCov">          0 :         return false;</span></a>
<a name="522"><span class="lineNum">     522 </span>            :     }</a>
<a name="523"><span class="lineNum">     523 </span>            : </a>
<a name="524"><span class="lineNum">     524 </span>            :     // ğŸ”§ CRITICAL: ä½¿ç”¨é”ä¿æŠ¤æŸ¥æ‰¾æ“ä½œ</a>
<a name="525"><span class="lineNum">     525 </span><span class="lineCov">        202 :     RegistryLock lock(const_cast&lt;pthread_mutex_t*&gt;(&amp;registry_-&gt;header.global_lock));</span></a>
<a name="526"><span class="lineNum">     526 </span><span class="lineCov">        202 :     if (!lock.isLocked()) {</span></a>
<a name="527"><span class="lineNum">     527 </span><span class="lineNoCov">          0 :         NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Failed to acquire lock for findNode&quot;);</span></a>
<a name="528"><span class="lineNum">     528 </span><span class="lineNoCov">          0 :         return false;</span></a>
<a name="529"><span class="lineNum">     529 </span>            :     }</a>
<a name="530"><span class="lineNum">     530 </span>            : </a>
<a name="531"><span class="lineNum">     531 </span><span class="lineCov">        202 :     int idx = findEntryIndex(node_id);</span></a>
<a name="532"><span class="lineNum">     532 </span><span class="lineCov">        202 :     if (idx &lt; 0) {</span></a>
<a name="533"><span class="lineNum">     533 </span><span class="lineCov">         59 :         return false;</span></a>
<a name="534"><span class="lineNum">     534 </span>            :     }</a>
<a name="535"><span class="lineNum">     535 </span>            : </a>
<a name="536"><span class="lineNum">     536 </span><span class="lineCov">        143 :     const RegistryEntry&amp; entry = registry_-&gt;entries[idx];</span></a>
<a name="537"><span class="lineNum">     537 </span>            : </a>
<a name="538"><span class="lineNum">     538 </span>            :     // ğŸ”§ Read all fields atomically</a>
<a name="539"><span class="lineNum">     539 </span><span class="lineCov">        143 :     info.node_id = readAtomicString(entry.node_id_atomic, NODE_ID_SIZE);</span></a>
<a name="540"><span class="lineNum">     540 </span><span class="lineCov">        143 :     info.shm_name = readAtomicString(entry.shm_name_atomic, SHM_NAME_SIZE);</span></a>
<a name="541"><span class="lineNum">     541 </span><span class="lineCov">        143 :     info.pid = entry.pid.load(std::memory_order_seq_cst);</span></a>
<a name="542"><span class="lineNum">     542 </span><span class="lineCov">        143 :     info.last_heartbeat = entry.last_heartbeat.load(std::memory_order_seq_cst);</span></a>
<a name="543"><span class="lineNum">     543 </span><span class="lineCov">        143 :     info.active = (entry.flags.load(std::memory_order_seq_cst) &amp; 0x2) != 0;</span></a>
<a name="544"><span class="lineNum">     544 </span>            : </a>
<a name="545"><span class="lineNum">     545 </span><span class="lineCov">        143 :     return true;</span></a>
<a name="546"><span class="lineNum">     546 </span><span class="lineCov">        202 : }</span></a>
<a name="547"><span class="lineNum">     547 </span>            : </a>
<a name="548"><span class="lineNum">     548 </span><span class="lineCov">         13 : bool SharedMemoryRegistry::nodeExists(const std::string&amp; node_id) const {</span></a>
<a name="549"><span class="lineNum">     549 </span><span class="lineCov">         13 :     if (!initialized_) {</span></a>
<a name="550"><span class="lineNum">     550 </span><span class="lineNoCov">          0 :         return false;</span></a>
<a name="551"><span class="lineNum">     551 </span>            :     }</a>
<a name="552"><span class="lineNum">     552 </span>            : </a>
<a name="553"><span class="lineNum">     553 </span>            :     // ğŸ”§ CRITICAL: ä½¿ç”¨é”ä¿æŠ¤æ£€æŸ¥æ“ä½œ</a>
<a name="554"><span class="lineNum">     554 </span><span class="lineCov">         13 :     RegistryLock lock(const_cast&lt;pthread_mutex_t*&gt;(&amp;registry_-&gt;header.global_lock));</span></a>
<a name="555"><span class="lineNum">     555 </span><span class="lineCov">         13 :     if (!lock.isLocked()) {</span></a>
<a name="556"><span class="lineNum">     556 </span><span class="lineNoCov">          0 :         return false;</span></a>
<a name="557"><span class="lineNum">     557 </span>            :     }</a>
<a name="558"><span class="lineNum">     558 </span>            : </a>
<a name="559"><span class="lineNum">     559 </span><span class="lineCov">         13 :     int idx = findEntryIndex(node_id);</span></a>
<a name="560"><span class="lineNum">     560 </span><span class="lineCov">         13 :     if (idx &lt; 0) {</span></a>
<a name="561"><span class="lineNum">     561 </span><span class="lineCov">          8 :         return false;</span></a>
<a name="562"><span class="lineNum">     562 </span>            :     }</a>
<a name="563"><span class="lineNum">     563 </span>            : </a>
<a name="564"><span class="lineNum">     564 </span>            :     // ğŸ”§ ä½¿ç”¨acquireè¯»å–flags</a>
<a name="565"><span class="lineNum">     565 </span><span class="lineCov">          5 :     uint32_t flags = registry_-&gt;entries[idx].flags.load(std::memory_order_acquire);</span></a>
<a name="566"><span class="lineNum">     566 </span><span class="lineCov">          5 :     return (flags &amp; 0x3) == 0x3;  // valid &amp;&amp; active</span></a>
<a name="567"><span class="lineNum">     567 </span><span class="lineCov">         13 : }</span></a>
<a name="568"><span class="lineNum">     568 </span>            : </a>
<a name="569"><span class="lineNum">     569 </span><span class="lineCov">        256 : int SharedMemoryRegistry::cleanupStaleNodes(uint64_t timeout_ms) {</span></a>
<a name="570"><span class="lineNum">     570 </span><span class="lineCov">        256 :     if (!initialized_) {</span></a>
<a name="571"><span class="lineNum">     571 </span><span class="lineNoCov">          0 :         return 0;</span></a>
<a name="572"><span class="lineNum">     572 </span>            :     }</a>
<a name="573"><span class="lineNum">     573 </span>            : </a>
<a name="574"><span class="lineNum">     574 </span>            :     // ğŸ”§ CRITICAL: ä½¿ç”¨é”ä¿æŠ¤æ¸…ç†æ“ä½œ</a>
<a name="575"><span class="lineNum">     575 </span><span class="lineCov">        256 :     RegistryLock lock(&amp;registry_-&gt;header.global_lock);</span></a>
<a name="576"><span class="lineNum">     576 </span><span class="lineCov">        256 :     if (!lock.isLocked()) {</span></a>
<a name="577"><span class="lineNum">     577 </span><span class="lineNoCov">          0 :         NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Failed to acquire lock for cleanupStaleNodes&quot;);</span></a>
<a name="578"><span class="lineNum">     578 </span><span class="lineNoCov">          0 :         return 0;</span></a>
<a name="579"><span class="lineNum">     579 </span>            :     }</a>
<a name="580"><span class="lineNum">     580 </span>            : </a>
<a name="581"><span class="lineNum">     581 </span><span class="lineCov">        256 :     int cleaned = 0;</span></a>
<a name="582"><span class="lineNum">     582 </span><span class="lineCov">        256 :     uint64_t now = getCurrentTimeMs();</span></a>
<a name="583"><span class="lineNum">     583 </span>            : </a>
<a name="584"><span class="lineNum">     584 </span><span class="lineCov">      65792 :     for (size_t i = 0; i &lt; MAX_REGISTRY_ENTRIES; ++i) {</span></a>
<a name="585"><span class="lineNum">     585 </span><span class="lineCov">      65536 :         RegistryEntry&amp; entry = registry_-&gt;entries[i];</span></a>
<a name="586"><span class="lineNum">     586 </span>            :         // ğŸ”§ Use seq_cst to see latest flags</a>
<a name="587"><span class="lineNum">     587 </span><span class="lineCov">      65536 :         uint32_t flags = entry.flags.load(std::memory_order_seq_cst);</span></a>
<a name="588"><span class="lineNum">     588 </span>            : </a>
<a name="589"><span class="lineNum">     589 </span><span class="lineCov">      65536 :         if ((flags &amp; 0x1) == 0) {  // Not valid</span></a>
<a name="590"><span class="lineNum">     590 </span><span class="lineCov">      65163 :             continue;</span></a>
<a name="591"><span class="lineNum">     591 </span>            :         }</a>
<a name="592"><span class="lineNum">     592 </span>            : </a>
<a name="593"><span class="lineNum">     593 </span>            :         // ğŸ”§ Read pid and heartbeat atomically</a>
<a name="594"><span class="lineNum">     594 </span><span class="lineCov">        373 :         pid_t pid = entry.pid.load(std::memory_order_seq_cst);</span></a>
<a name="595"><span class="lineNum">     595 </span><span class="lineCov">        373 :         uint64_t last_hb = entry.last_heartbeat.load(std::memory_order_seq_cst);</span></a>
<a name="596"><span class="lineNum">     596 </span>            : </a>
<a name="597"><span class="lineNum">     597 </span>            :         // ğŸ”§ CRITICAL: Skip entries being initialized (last_hb == 0)</a>
<a name="598"><span class="lineNum">     598 </span>            :         // During concurrent registration with CAS, an entry may have valid bit set</a>
<a name="599"><span class="lineNum">     599 </span>            :         // but other fields (node_id, pid, last_hb) are still being written</a>
<a name="600"><span class="lineNum">     600 </span>            :         // Wait until initialization is complete before checking timeout</a>
<a name="601"><span class="lineNum">     601 </span><span class="lineCov">        373 :         if (last_hb == 0) {</span></a>
<a name="602"><span class="lineNum">     602 </span><span class="lineNoCov">          0 :             continue;  // Entry is being initialized, skip it</span></a>
<a name="603"><span class="lineNum">     603 </span>            :         }</a>
<a name="604"><span class="lineNum">     604 </span>            : </a>
<a name="605"><span class="lineNum">     605 </span>            :         // ğŸ”§ CRITICAL: ä½¿ç”¨steady_clockåä¸ä¼šæœ‰æ—¶é’Ÿå›é€€é—®é¢˜</a>
<a name="606"><span class="lineNum">     606 </span>            :         // ä½†ä»éœ€å¤„ç†è·¨è¿›ç¨‹çš„æ—¶é—´æˆ³ï¼ˆæ¯ä¸ªè¿›ç¨‹çš„steady_clock epochä¸åŒï¼‰</a>
<a name="607"><span class="lineNum">     607 </span>            :         // å› æ­¤è¿™é‡Œçš„è¶…æ—¶æ£€æµ‹ä»…ä½œä¸ºè¾…åŠ©ï¼Œä¸»è¦ä¾èµ–kill(pid,0)æ£€æµ‹è¿›ç¨‹å­˜æ´»</a>
<a name="608"><span class="lineNum">     608 </span><span class="lineCov">        373 :         uint64_t time_since_hb = 0;</span></a>
<a name="609"><span class="lineNum">     609 </span><span class="lineCov">        373 :         if (now &gt;= last_hb) {</span></a>
<a name="610"><span class="lineNum">     610 </span><span class="lineCov">        373 :             time_since_hb = now - last_hb;</span></a>
<a name="611"><span class="lineNum">     611 </span>            :         } else {</a>
<a name="612"><span class="lineNum">     612 </span>            :             // è·¨è¿›ç¨‹æ—¶é—´æˆ³ä¸å¯æ¯”ï¼Œè§†ä¸ºæ–°é²œå¿ƒè·³</a>
<a name="613"><span class="lineNum">     613 </span><span class="lineNoCov">          0 :             time_since_hb = 0;</span></a>
<a name="614"><span class="lineNum">     614 </span>            :         }</a>
<a name="615"><span class="lineNum">     615 </span>            : </a>
<a name="616"><span class="lineNum">     616 </span><span class="lineCov">        373 :         bool timeout = time_since_hb &gt; timeout_ms;</span></a>
<a name="617"><span class="lineNum">     617 </span><span class="lineCov">        373 :         bool process_dead = !isProcessAlive(pid);</span></a>
<a name="618"><span class="lineNum">     618 </span>            : </a>
<a name="619"><span class="lineNum">     619 </span><span class="lineCov">        373 :         if (timeout || process_dead) {</span></a>
<a name="620"><span class="lineNum">     620 </span>            :             // ğŸ”§ CRITICAL: è¯»å–ç‰ˆæœ¬å·ï¼Œç¨åéªŒè¯ä»¥é˜²æ­¢ABAé—®é¢˜</a>
<a name="621"><span class="lineNum">     621 </span><span class="lineCov">         10 :             uint32_t version_before = entry.version.load(std::memory_order_acquire);</span></a>
<a name="622"><span class="lineNum">     622 </span>            : </a>
<a name="623"><span class="lineNum">     623 </span>            :             // Read node_id for logging</a>
<a name="624"><span class="lineNum">     624 </span><span class="lineCov">         10 :             std::string node_id_str = readAtomicString(entry.node_id_atomic, NODE_ID_SIZE);</span></a>
<a name="625"><span class="lineNum">     625 </span>            : </a>
<a name="626"><span class="lineNum">     626 </span>            :             // ğŸ”§ è¯¦ç»†æ—¥å¿—ï¼šæ˜¾ç¤ºå¿ƒè·³æ—¶é—´å·®ï¼Œå¸®åŠ©è¯Šæ–­</a>
<a name="627"><span class="lineNum">     627 </span><span class="lineCov">         10 :             std::string reason;</span></a>
<a name="628"><span class="lineNum">     628 </span><span class="lineCov">         10 :             if (timeout) {</span></a>
<a name="629"><span class="lineNum">     629 </span><span class="lineCov">         10 :                 reason = &quot; (timeout: last_hb=&quot; + std::to_string(last_hb) + &quot;ms, now=&quot; + std::to_string(now) +</span></a>
<a name="630"><span class="lineNum">     630 </span><span class="lineCov">         15 :                          &quot;ms, diff=&quot; + std::to_string(time_since_hb) + &quot;ms &gt; &quot; + std::to_string(timeout_ms) + &quot;ms)&quot;;</span></a>
<a name="631"><span class="lineNum">     631 </span>            :             } else {</a>
<a name="632"><span class="lineNum">     632 </span><span class="lineCov">          5 :                 reason = &quot; (process dead)&quot;;</span></a>
<a name="633"><span class="lineNum">     633 </span>            :             }</a>
<a name="634"><span class="lineNum">     634 </span>            : </a>
<a name="635"><span class="lineNum">     635 </span><span class="lineCov">         10 :             NEXUS_LOG_INFO(&quot;Registry&quot;, &quot;Cleaning stale node: &quot; + node_id_str + reason);</span></a>
<a name="636"><span class="lineNum">     636 </span>            : </a>
<a name="637"><span class="lineNum">     637 </span>            :             // ğŸ”§ CRITICAL: ä½¿ç”¨CASéªŒè¯ç‰ˆæœ¬å·å¹¶æ¸…é™¤flagsï¼Œé˜²æ­¢TOCTOU</a>
<a name="638"><span class="lineNum">     638 </span>            :             // å¦‚æœç‰ˆæœ¬å·å·²æ”¹å˜ï¼Œè¯´æ˜entryè¢«é‡ç”¨ï¼Œè·³è¿‡æ¸…ç†</a>
<a name="639"><span class="lineNum">     639 </span><span class="lineCov">         10 :             uint32_t expected_version = version_before;</span></a>
<a name="640"><span class="lineNum">     640 </span><span class="lineCov">         10 :             uint32_t new_version = version_before + 1;</span></a>
<a name="641"><span class="lineNum">     641 </span>            : </a>
<a name="642"><span class="lineNum">     642 </span>            :             // å°è¯•é€’å¢ç‰ˆæœ¬å·ï¼Œå¦‚æœæˆåŠŸè¯´æ˜æ²¡æœ‰è¢«é‡ç”¨</a>
<a name="643"><span class="lineNum">     643 </span><span class="lineCov">         20 :             if (!entry.version.compare_exchange_strong(expected_version, new_version, std::memory_order_acq_rel)) {</span></a>
<a name="644"><span class="lineNum">     644 </span>            :                 // Version changed, entry was reused, skip cleanup</a>
<a name="645"><span class="lineNum">     645 </span><span class="lineNoCov">          0 :                 continue;</span></a>
<a name="646"><span class="lineNum">     646 </span>            :             }</a>
<a name="647"><span class="lineNum">     647 </span>            : </a>
<a name="648"><span class="lineNum">     648 </span>            :             // ğŸ”§ Clear flags to invalidate entry</a>
<a name="649"><span class="lineNum">     649 </span><span class="lineCov">         10 :             entry.flags.store(0, std::memory_order_seq_cst);</span></a>
<a name="650"><span class="lineNum">     650 </span>            : </a>
<a name="651"><span class="lineNum">     651 </span>            :             // ğŸ”§ Increment version to prevent ABA problem</a>
<a name="652"><span class="lineNum">     652 </span><span class="lineCov">         10 :             entry.version.fetch_add(1, std::memory_order_release);</span></a>
<a name="653"><span class="lineNum">     653 </span>            : </a>
<a name="654"><span class="lineNum">     654 </span>            :             // ğŸ”§ Clear other atomic fields (use release for visibility)</a>
<a name="655"><span class="lineNum">     655 </span><span class="lineCov">         10 :             entry.pid.store(0, std::memory_order_release);</span></a>
<a name="656"><span class="lineNum">     656 </span><span class="lineCov">         10 :             entry.last_heartbeat.store(0, std::memory_order_release);</span></a>
<a name="657"><span class="lineNum">     657 </span><span class="lineCov">         90 :             for (size_t j = 0; j &lt; 8; ++j) {</span></a>
<a name="658"><span class="lineNum">     658 </span><span class="lineCov">         80 :                 entry.node_id_atomic[j].store(0, std::memory_order_release);</span></a>
<a name="659"><span class="lineNum">     659 </span><span class="lineCov">         80 :                 entry.shm_name_atomic[j].store(0, std::memory_order_release);</span></a>
<a name="660"><span class="lineNum">     660 </span>            :             }</a>
<a name="661"><span class="lineNum">     661 </span>            : </a>
<a name="662"><span class="lineNum">     662 </span>            :             // ğŸ”§ Decrement count (use release)</a>
<a name="663"><span class="lineNum">     663 </span><span class="lineCov">         10 :             registry_-&gt;header.num_entries.fetch_sub(1, std::memory_order_release);</span></a>
<a name="664"><span class="lineNum">     664 </span>            : </a>
<a name="665"><span class="lineNum">     665 </span><span class="lineCov">         10 :             cleaned++;</span></a>
<a name="666"><span class="lineNum">     666 </span><span class="lineCov">         10 :         }</span></a>
<a name="667"><span class="lineNum">     667 </span>            :     }</a>
<a name="668"><span class="lineNum">     668 </span>            : </a>
<a name="669"><span class="lineNum">     669 </span><span class="lineCov">        256 :     return cleaned;</span></a>
<a name="670"><span class="lineNum">     670 </span><span class="lineCov">        256 : }</span></a>
<a name="671"><span class="lineNum">     671 </span>            : </a>
<a name="672"><span class="lineNum">     672 </span><span class="lineCov">          4 : int SharedMemoryRegistry::getActiveNodeCount() const {</span></a>
<a name="673"><span class="lineNum">     673 </span><span class="lineCov">          4 :     if (!initialized_) {</span></a>
<a name="674"><span class="lineNum">     674 </span><span class="lineNoCov">          0 :         return 0;</span></a>
<a name="675"><span class="lineNum">     675 </span>            :     }</a>
<a name="676"><span class="lineNum">     676 </span>            : </a>
<a name="677"><span class="lineNum">     677 </span>            :     // ğŸ”§ Use acquire to see latest count updates</a>
<a name="678"><span class="lineNum">     678 </span><span class="lineCov">          8 :     return registry_-&gt;header.num_entries.load(std::memory_order_acquire);</span></a>
<a name="679"><span class="lineNum">     679 </span>            : }</a>
<a name="680"><span class="lineNum">     680 </span>            : </a>
<a name="681"><span class="lineNum">     681 </span><span class="lineCov">          4 : bool SharedMemoryRegistry::amICleanupMaster() const {</span></a>
<a name="682"><span class="lineNum">     682 </span><span class="lineCov">          4 :     if (!initialized_) {</span></a>
<a name="683"><span class="lineNum">     683 </span><span class="lineNoCov">          0 :         return false;</span></a>
<a name="684"><span class="lineNum">     684 </span>            :     }</a>
<a name="685"><span class="lineNum">     685 </span>            : </a>
<a name="686"><span class="lineNum">     686 </span><span class="lineCov">          4 :     RegistryLock lock(&amp;registry_-&gt;header.global_lock, 1000);</span></a>
<a name="687"><span class="lineNum">     687 </span><span class="lineCov">          4 :     if (!lock.isLocked()) {</span></a>
<a name="688"><span class="lineNum">     688 </span><span class="lineNoCov">          0 :         return false;  // Can't acquire lock, not safe to cleanup</span></a>
<a name="689"><span class="lineNum">     689 </span>            :     }</a>
<a name="690"><span class="lineNum">     690 </span>            : </a>
<a name="691"><span class="lineNum">     691 </span><span class="lineCov">          4 :     pid_t my_pid = getpid();</span></a>
<a name="692"><span class="lineNum">     692 </span><span class="lineCov">          4 :     pid_t smallest_active_pid = INT32_MAX;</span></a>
<a name="693"><span class="lineNum">     693 </span>            : </a>
<a name="694"><span class="lineNum">     694 </span>            :     // Find smallest PID among all active processes</a>
<a name="695"><span class="lineNum">     695 </span><span class="lineCov">       1028 :     for (int i = 0; i &lt; MAX_REGISTRY_ENTRIES; ++i) {</span></a>
<a name="696"><span class="lineNum">     696 </span><span class="lineCov">       1024 :         pid_t pid = registry_-&gt;header.ref_pids[i].load(std::memory_order_acquire);</span></a>
<a name="697"><span class="lineNum">     697 </span><span class="lineCov">       1024 :         if (pid &gt; 0) {</span></a>
<a name="698"><span class="lineNum">     698 </span>            :             // Verify process is still alive</a>
<a name="699"><span class="lineNum">     699 </span><span class="lineCov">          6 :             if (kill(pid, 0) == 0 || errno == EPERM) {</span></a>
<a name="700"><span class="lineNum">     700 </span><span class="lineCov">          6 :                 if (pid &lt; smallest_active_pid) {</span></a>
<a name="701"><span class="lineNum">     701 </span><span class="lineCov">          4 :                     smallest_active_pid = pid;</span></a>
<a name="702"><span class="lineNum">     702 </span>            :                 }</a>
<a name="703"><span class="lineNum">     703 </span>            :             }</a>
<a name="704"><span class="lineNum">     704 </span>            :         }</a>
<a name="705"><span class="lineNum">     705 </span>            :     }</a>
<a name="706"><span class="lineNum">     706 </span>            : </a>
<a name="707"><span class="lineNum">     707 </span>            :     // I'm the cleanup master if I have the smallest PID</a>
<a name="708"><span class="lineNum">     708 </span><span class="lineCov">          4 :     return (my_pid == smallest_active_pid);</span></a>
<a name="709"><span class="lineNum">     709 </span><span class="lineCov">          4 : }</span></a>
<a name="710"><span class="lineNum">     710 </span>            : </a>
<a name="711"><span class="lineNum">     711 </span><span class="lineCov">        135 : bool SharedMemoryRegistry::cleanupOrphanedRegistry() {</span></a>
<a name="712"><span class="lineNum">     712 </span>            :     // Try to open registry</a>
<a name="713"><span class="lineNum">     713 </span><span class="lineCov">        135 :     int fd = shm_open(REGISTRY_SHM_NAME, O_RDWR, 0666);</span></a>
<a name="714"><span class="lineNum">     714 </span><span class="lineCov">        135 :     if (fd &lt; 0) {</span></a>
<a name="715"><span class="lineNum">     715 </span><span class="lineCov">          4 :         return true;  // No registry to clean</span></a>
<a name="716"><span class="lineNum">     716 </span>            :     }</a>
<a name="717"><span class="lineNum">     717 </span>            : </a>
<a name="718"><span class="lineNum">     718 </span>            :     // Map it</a>
<a name="719"><span class="lineNum">     719 </span><span class="lineCov">        131 :     void* ptr = mmap(nullptr, sizeof(RegistryRegion), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</span></a>
<a name="720"><span class="lineNum">     720 </span><span class="lineCov">        131 :     if (ptr == MAP_FAILED) {</span></a>
<a name="721"><span class="lineNum">     721 </span><span class="lineNoCov">          0 :         close(fd);</span></a>
<a name="722"><span class="lineNum">     722 </span>            :         // ğŸ”§ mmap å¤±è´¥ä¸ç«‹å³åˆ é™¤shmï¼Œå¯èƒ½å…¶ä»–è¿›ç¨‹æ­£åœ¨ä½¿ç”¨</a>
<a name="723"><span class="lineNum">     723 </span>            :         // è®©ä¸‹æ¬¡cleanupåœ¨è·å–é”åå†åˆ¤æ–­æ˜¯å¦åˆ é™¤</a>
<a name="724"><span class="lineNum">     724 </span><span class="lineNoCov">          0 :         NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Failed to mmap registry in cleanup: &quot; + std::string(strerror(errno)));</span></a>
<a name="725"><span class="lineNum">     725 </span><span class="lineNoCov">          0 :         return false;</span></a>
<a name="726"><span class="lineNum">     726 </span>            :     }</a>
<a name="727"><span class="lineNum">     727 </span>            : </a>
<a name="728"><span class="lineNum">     728 </span><span class="lineCov">        131 :     RegistryRegion* reg = static_cast&lt;RegistryRegion*&gt;(ptr);</span></a>
<a name="729"><span class="lineNum">     729 </span>            : </a>
<a name="730"><span class="lineNum">     730 </span>            :     // ğŸ”§ CRITICAL: ä½¿ç”¨ pthread_mutex è€Œä¸æ˜¯ flockï¼Œä¿æŒä¸€è‡´æ€§</a>
<a name="731"><span class="lineNum">     731 </span>            :     // å°è¯•è·å–é”ï¼Œå¦‚æœè·å–å¤±è´¥è¯´æ˜æœ‰å…¶ä»–è¿›ç¨‹æ­£åœ¨ä½¿ç”¨</a>
<a name="732"><span class="lineNum">     732 </span>            :     struct timespec ts;</a>
<a name="733"><span class="lineNum">     733 </span><span class="lineCov">        131 :     clock_gettime(CLOCK_REALTIME, &amp;ts);</span></a>
<a name="734"><span class="lineNum">     734 </span><span class="lineCov">        131 :     ts.tv_sec += 1;  // 1ç§’è¶…æ—¶</span></a>
<a name="735"><span class="lineNum">     735 </span>            : </a>
<a name="736"><span class="lineNum">     736 </span><span class="lineCov">        131 :     int lock_result = pthread_mutex_timedlock(&amp;reg-&gt;header.global_lock, &amp;ts);</span></a>
<a name="737"><span class="lineNum">     737 </span>            : </a>
<a name="738"><span class="lineNum">     738 </span><span class="lineCov">        131 :     if (lock_result == ETIMEDOUT) {</span></a>
<a name="739"><span class="lineNum">     739 </span><span class="lineCov">          2 :         NEXUS_LOG_INFO(&quot;Registry&quot;, &quot;Registry is being used by another process, skipping cleanup&quot;);</span></a>
<a name="740"><span class="lineNum">     740 </span><span class="lineCov">          2 :         munmap(ptr, sizeof(RegistryRegion));</span></a>
<a name="741"><span class="lineNum">     741 </span><span class="lineCov">          2 :         close(fd);</span></a>
<a name="742"><span class="lineNum">     742 </span><span class="lineCov">          2 :         return true;</span></a>
<a name="743"><span class="lineNum">     743 </span>            :     }</a>
<a name="744"><span class="lineNum">     744 </span>            : </a>
<a name="745"><span class="lineNum">     745 </span><span class="lineCov">        129 :     if (lock_result == EOWNERDEAD) {</span></a>
<a name="746"><span class="lineNum">     746 </span>            :         // é”æŒæœ‰è€…å´©æºƒï¼Œæ¢å¤é”å¹¶ç»§ç»­</a>
<a name="747"><span class="lineNum">     747 </span><span class="lineNoCov">          0 :         NEXUS_LOG_WARN(&quot;Registry&quot;, &quot;Recovered mutex from dead process in cleanupOrphanedRegistry&quot;);</span></a>
<a name="748"><span class="lineNum">     748 </span><span class="lineNoCov">          0 :         pthread_mutex_consistent(&amp;reg-&gt;header.global_lock);</span></a>
<a name="749"><span class="lineNum">     749 </span><span class="lineCov">        129 :     } else if (lock_result != 0) {</span></a>
<a name="750"><span class="lineNum">     750 </span><span class="lineNoCov">          0 :         NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Failed to acquire lock for cleanup: &quot; + std::string(strerror(lock_result)));</span></a>
<a name="751"><span class="lineNum">     751 </span><span class="lineNoCov">          0 :         munmap(ptr, sizeof(RegistryRegion));</span></a>
<a name="752"><span class="lineNum">     752 </span><span class="lineNoCov">          0 :         close(fd);</span></a>
<a name="753"><span class="lineNum">     753 </span><span class="lineNoCov">          0 :         return true;</span></a>
<a name="754"><span class="lineNum">     754 </span>            :     }</a>
<a name="755"><span class="lineNum">     755 </span>            : </a>
<a name="756"><span class="lineNum">     756 </span>            :     // ğŸ”§ æ£€æŸ¥ magic number</a>
<a name="757"><span class="lineNum">     757 </span>            :     std::atomic_thread_fence(std::memory_order_acquire);</a>
<a name="758"><span class="lineNum">     758 </span><span class="lineCov">        258 :     if (reg-&gt;header.magic.load(std::memory_order_acquire) == MAGIC) {</span></a>
<a name="759"><span class="lineNum">     759 </span>            :         // Registry is valid, check ref_count and process liveness</a>
<a name="760"><span class="lineNum">     760 </span><span class="lineCov">        124 :         uint32_t ref_count = reg-&gt;header.ref_count.load(std::memory_order_acquire);</span></a>
<a name="761"><span class="lineNum">     761 </span>            : </a>
<a name="762"><span class="lineNum">     762 </span>            :         // ğŸ”§ CRITICAL: æ£€æŸ¥ ref_pids ä¸­çš„è¿›ç¨‹æ˜¯å¦è¿˜å­˜æ´»</a>
<a name="763"><span class="lineNum">     763 </span>            :         // å¦‚æœè¿›ç¨‹å´©æºƒï¼Œref_count å¯èƒ½ä¸å‡†ç¡®ï¼Œéœ€è¦å®é™…æ£€æŸ¥è¿›ç¨‹</a>
<a name="764"><span class="lineNum">     764 </span>            :         // ä½¿ç”¨ set å»é‡ï¼Œé¿å…åŒä¸€è¿›ç¨‹åœ¨ ref_pids å’Œ entries ä¸­è¢«é‡å¤è®¡æ•°</a>
<a name="765"><span class="lineNum">     765 </span><span class="lineCov">        124 :         std::set&lt;pid_t&gt; alive_pids;</span></a>
<a name="766"><span class="lineNum">     766 </span>            : </a>
<a name="767"><span class="lineNum">     767 </span>            :         // æ£€æŸ¥ ref_pids</a>
<a name="768"><span class="lineNum">     768 </span><span class="lineCov">      31868 :         for (size_t i = 0; i &lt; MAX_REGISTRY_ENTRIES; ++i) {</span></a>
<a name="769"><span class="lineNum">     769 </span><span class="lineCov">      31744 :             pid_t pid = reg-&gt;header.ref_pids[i].load(std::memory_order_acquire);</span></a>
<a name="770"><span class="lineNum">     770 </span><span class="lineCov">      31744 :             if (pid &gt; 0 &amp;&amp; kill(pid, 0) == 0) {</span></a>
<a name="771"><span class="lineNum">     771 </span><span class="lineCov">          4 :                 alive_pids.insert(pid);</span></a>
<a name="772"><span class="lineNum">     772 </span>            :             }</a>
<a name="773"><span class="lineNum">     773 </span>            :         }</a>
<a name="774"><span class="lineNum">     774 </span>            : </a>
<a name="775"><span class="lineNum">     775 </span>            :         // é¢å¤–æ£€æŸ¥ entries ä¸­çš„è¿›ç¨‹ï¼ˆè‡ªåŠ¨å»é‡ï¼‰</a>
<a name="776"><span class="lineNum">     776 </span><span class="lineCov">      31868 :         for (size_t i = 0; i &lt; MAX_REGISTRY_ENTRIES; ++i) {</span></a>
<a name="777"><span class="lineNum">     777 </span><span class="lineCov">      31744 :             uint32_t flags = reg-&gt;entries[i].flags.load(std::memory_order_acquire);</span></a>
<a name="778"><span class="lineNum">     778 </span><span class="lineCov">      31744 :             if (flags &amp; 0x1) {</span></a>
<a name="779"><span class="lineNum">     779 </span><span class="lineCov">        720 :                 pid_t pid = reg-&gt;entries[i].pid.load(std::memory_order_acquire);</span></a>
<a name="780"><span class="lineNum">     780 </span><span class="lineCov">        720 :                 if (pid &gt; 0 &amp;&amp; kill(pid, 0) == 0) {</span></a>
<a name="781"><span class="lineNum">     781 </span><span class="lineCov">        720 :                     alive_pids.insert(pid);</span></a>
<a name="782"><span class="lineNum">     782 </span>            :                 }</a>
<a name="783"><span class="lineNum">     783 </span>            :             }</a>
<a name="784"><span class="lineNum">     784 </span>            :         }</a>
<a name="785"><span class="lineNum">     785 </span>            : </a>
<a name="786"><span class="lineNum">     786 </span><span class="lineCov">        124 :         int alive_count = alive_pids.size();</span></a>
<a name="787"><span class="lineNum">     787 </span>            : </a>
<a name="788"><span class="lineNum">     788 </span>            :         // ğŸ”§ ç°åœ¨æœ‰äº†è¿›ç¨‹é—´äº’æ–¥é”ï¼Œå¯ä»¥å®‰å…¨åœ°åˆ é™¤ registry</a>
<a name="789"><span class="lineNum">     789 </span>            :         // flock ç¡®ä¿æ²¡æœ‰å…¶ä»–è¿›ç¨‹æ­£åœ¨è®¿é—®</a>
<a name="790"><span class="lineNum">     790 </span>            : </a>
<a name="791"><span class="lineNum">     791 </span><span class="lineCov">        124 :         if (alive_count == 0) {</span></a>
<a name="792"><span class="lineNum">     792 </span>            :             // ğŸ”§ SAFE: åœ¨é”ä¿æŠ¤ä¸‹åˆ é™¤ï¼Œä¸ä¼šæœ‰ Bus error</a>
<a name="793"><span class="lineNum">     793 </span><span class="lineCov">        110 :             pthread_mutex_unlock(&amp;reg-&gt;header.global_lock);</span></a>
<a name="794"><span class="lineNum">     794 </span><span class="lineCov">        110 :             munmap(ptr, sizeof(RegistryRegion));</span></a>
<a name="795"><span class="lineNum">     795 </span><span class="lineCov">        110 :             close(fd);</span></a>
<a name="796"><span class="lineNum">     796 </span><span class="lineCov">        110 :             shm_unlink(REGISTRY_SHM_NAME);</span></a>
<a name="797"><span class="lineNum">     797 </span><span class="lineCov">        110 :             NEXUS_LOG_INFO(&quot;Registry&quot;,</span></a>
<a name="798"><span class="lineNum">     798 </span>            :                            &quot;Cleaned up orphaned registry (alive_count=0, ref_count=&quot; + std::to_string(ref_count) + &quot;)&quot;);</a>
<a name="799"><span class="lineNum">     799 </span>            :         } else {</a>
<a name="800"><span class="lineNum">     800 </span><span class="lineCov">         14 :             NEXUS_LOG_INFO(&quot;Registry&quot;, &quot;Registry has &quot; + std::to_string(alive_count) + &quot; alive processes (ref_count=&quot; +</span></a>
<a name="801"><span class="lineNum">     801 </span>            :                                            std::to_string(ref_count) + &quot;), keeping it&quot;);</a>
<a name="802"><span class="lineNum">     802 </span><span class="lineCov">         14 :             pthread_mutex_unlock(&amp;reg-&gt;header.global_lock);</span></a>
<a name="803"><span class="lineNum">     803 </span><span class="lineCov">         14 :             munmap(ptr, sizeof(RegistryRegion));</span></a>
<a name="804"><span class="lineNum">     804 </span><span class="lineCov">         14 :             close(fd);</span></a>
<a name="805"><span class="lineNum">     805 </span>            :         }</a>
<a name="806"><span class="lineNum">     806 </span><span class="lineCov">        124 :     } else {</span></a>
<a name="807"><span class="lineNum">     807 </span>            :         // Magic number æ— æ•ˆï¼Œå¯èƒ½æ˜¯æ­£åœ¨åˆå§‹åŒ–ä¸­æˆ–æŸå</a>
<a name="808"><span class="lineNum">     808 </span>            :         // ğŸ”§ æ­¤æ—¶å·²ç»æŒæœ‰é”ï¼ˆå‡½æ•°å¼€å¤´è·å–ï¼‰ï¼Œç›´æ¥æ£€æŸ¥</a>
<a name="809"><span class="lineNum">     809 </span><span class="lineCov">          5 :         uint32_t current_magic = reg-&gt;header.magic.load(std::memory_order_acquire);</span></a>
<a name="810"><span class="lineNum">     810 </span>            : </a>
<a name="811"><span class="lineNum">     811 </span><span class="lineCov">          5 :         if (current_magic == 0) {</span></a>
<a name="812"><span class="lineNum">     812 </span>            :             // ç¡®è®¤æŸåï¼Œåˆ é™¤å¹¶è®©ä¸‹æ¬¡åˆå§‹åŒ–é‡å»º</a>
<a name="813"><span class="lineNum">     813 </span><span class="lineCov">          4 :             NEXUS_LOG_WARN(&quot;Registry&quot;, &quot;Detected corrupted registry (magic=0), removing for rebuild&quot;);</span></a>
<a name="814"><span class="lineNum">     814 </span><span class="lineCov">          4 :             pthread_mutex_unlock(&amp;reg-&gt;header.global_lock);</span></a>
<a name="815"><span class="lineNum">     815 </span><span class="lineCov">          4 :             munmap(ptr, sizeof(RegistryRegion));</span></a>
<a name="816"><span class="lineNum">     816 </span><span class="lineCov">          4 :             close(fd);</span></a>
<a name="817"><span class="lineNum">     817 </span><span class="lineCov">          4 :             shm_unlink(REGISTRY_SHM_NAME);</span></a>
<a name="818"><span class="lineNum">     818 </span><span class="lineCov">          4 :             return true;</span></a>
<a name="819"><span class="lineNum">     819 </span>            :         }</a>
<a name="820"><span class="lineNum">     820 </span>            : </a>
<a name="821"><span class="lineNum">     821 </span>            :         // Magic ä¸æ˜¯ 0 ä¹Ÿä¸æ˜¯ MAGICï¼Œå¯èƒ½æ­£åœ¨åˆå§‹åŒ–ä¸­</a>
<a name="822"><span class="lineNum">     822 </span><span class="lineCov">          1 :         pthread_mutex_unlock(&amp;reg-&gt;header.global_lock);</span></a>
<a name="823"><span class="lineNum">     823 </span><span class="lineCov">          1 :         munmap(ptr, sizeof(RegistryRegion));</span></a>
<a name="824"><span class="lineNum">     824 </span><span class="lineCov">          1 :         close(fd);</span></a>
<a name="825"><span class="lineNum">     825 </span><span class="lineCov">          1 :         NEXUS_LOG_WARN(&quot;Registry&quot;,</span></a>
<a name="826"><span class="lineNum">     826 </span>            :                        &quot;Found registry with invalid magic (&quot; + std::to_string(current_magic) + &quot;), skipping cleanup&quot;);</a>
<a name="827"><span class="lineNum">     827 </span>            :     }</a>
<a name="828"><span class="lineNum">     828 </span>            : </a>
<a name="829"><span class="lineNum">     829 </span><span class="lineCov">        125 :     return true;</span></a>
<a name="830"><span class="lineNum">     830 </span>            : }</a>
<a name="831"><span class="lineNum">     831 </span>            : </a>
<a name="832"><span class="lineNum">     832 </span><span class="lineCov">         51 : bool SharedMemoryRegistry::forceRemoveRegistry() {</span></a>
<a name="833"><span class="lineNum">     833 </span>            :     // ğŸ”§ CRITICAL: åœ¨åˆ é™¤å‰å°è¯•è·å–é”ï¼Œç¡®ä¿æ²¡æœ‰å…¶ä»–è¿›ç¨‹æ­£åœ¨ä½¿ç”¨</a>
<a name="834"><span class="lineNum">     834 </span><span class="lineCov">         51 :     int fd = shm_open(REGISTRY_SHM_NAME, O_RDWR, 0666);</span></a>
<a name="835"><span class="lineNum">     835 </span><span class="lineCov">         51 :     if (fd &lt; 0) {</span></a>
<a name="836"><span class="lineNum">     836 </span><span class="lineCov">         32 :         if (errno == ENOENT) {</span></a>
<a name="837"><span class="lineNum">     837 </span><span class="lineCov">         32 :             NEXUS_LOG_INFO(&quot;Registry&quot;, &quot;Registry does not exist, nothing to remove&quot;);</span></a>
<a name="838"><span class="lineNum">     838 </span><span class="lineCov">         32 :             return true;</span></a>
<a name="839"><span class="lineNum">     839 </span>            :         }</a>
<a name="840"><span class="lineNum">     840 </span>            :         // å…¶ä»–é”™è¯¯ï¼Œå°è¯•åˆ é™¤</a>
<a name="841"><span class="lineNum">     841 </span><span class="lineNoCov">          0 :         int result = shm_unlink(REGISTRY_SHM_NAME);</span></a>
<a name="842"><span class="lineNum">     842 </span><span class="lineNoCov">          0 :         return result == 0;</span></a>
<a name="843"><span class="lineNum">     843 </span>            :     }</a>
<a name="844"><span class="lineNum">     844 </span>            : </a>
<a name="845"><span class="lineNum">     845 </span>            :     // å°è¯•mmap</a>
<a name="846"><span class="lineNum">     846 </span><span class="lineCov">         19 :     void* ptr = mmap(nullptr, sizeof(RegistryRegion), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</span></a>
<a name="847"><span class="lineNum">     847 </span><span class="lineCov">         19 :     if (ptr == MAP_FAILED) {</span></a>
<a name="848"><span class="lineNum">     848 </span><span class="lineNoCov">          0 :         close(fd);</span></a>
<a name="849"><span class="lineNum">     849 </span>            :         // mmapå¤±è´¥ï¼Œç›´æ¥åˆ é™¤</a>
<a name="850"><span class="lineNum">     850 </span><span class="lineNoCov">          0 :         int result = shm_unlink(REGISTRY_SHM_NAME);</span></a>
<a name="851"><span class="lineNum">     851 </span><span class="lineNoCov">          0 :         if (result == 0) {</span></a>
<a name="852"><span class="lineNum">     852 </span><span class="lineNoCov">          0 :             NEXUS_LOG_WARN(&quot;Registry&quot;, &quot;Force removed registry: &quot; + std::string(REGISTRY_SHM_NAME));</span></a>
<a name="853"><span class="lineNum">     853 </span><span class="lineNoCov">          0 :             return true;</span></a>
<a name="854"><span class="lineNum">     854 </span>            :         }</a>
<a name="855"><span class="lineNum">     855 </span><span class="lineNoCov">          0 :         return false;</span></a>
<a name="856"><span class="lineNum">     856 </span>            :     }</a>
<a name="857"><span class="lineNum">     857 </span>            : </a>
<a name="858"><span class="lineNum">     858 </span><span class="lineCov">         19 :     RegistryRegion* reg = static_cast&lt;RegistryRegion*&gt;(ptr);</span></a>
<a name="859"><span class="lineNum">     859 </span>            : </a>
<a name="860"><span class="lineNum">     860 </span>            :     // å°è¯•è·å–é”ï¼ˆçŸ­è¶…æ—¶ï¼‰</a>
<a name="861"><span class="lineNum">     861 </span>            :     struct timespec ts;</a>
<a name="862"><span class="lineNum">     862 </span><span class="lineCov">         19 :     clock_gettime(CLOCK_REALTIME, &amp;ts);</span></a>
<a name="863"><span class="lineNum">     863 </span><span class="lineCov">         19 :     ts.tv_sec += 1;</span></a>
<a name="864"><span class="lineNum">     864 </span>            : </a>
<a name="865"><span class="lineNum">     865 </span><span class="lineCov">         19 :     int lock_result = pthread_mutex_timedlock(&amp;reg-&gt;header.global_lock, &amp;ts);</span></a>
<a name="866"><span class="lineNum">     866 </span>            : </a>
<a name="867"><span class="lineNum">     867 </span><span class="lineCov">         19 :     if (lock_result == EOWNERDEAD) {</span></a>
<a name="868"><span class="lineNum">     868 </span><span class="lineNoCov">          0 :         pthread_mutex_consistent(&amp;reg-&gt;header.global_lock);</span></a>
<a name="869"><span class="lineNum">     869 </span><span class="lineNoCov">          0 :         lock_result = 0;</span></a>
<a name="870"><span class="lineNum">     870 </span>            :     }</a>
<a name="871"><span class="lineNum">     871 </span>            : </a>
<a name="872"><span class="lineNum">     872 </span><span class="lineCov">         19 :     if (lock_result == 0) {</span></a>
<a name="873"><span class="lineNum">     873 </span>            :         // æˆåŠŸè·å–é”ï¼Œå®‰å…¨åˆ é™¤</a>
<a name="874"><span class="lineNum">     874 </span><span class="lineCov">         17 :         pthread_mutex_unlock(&amp;reg-&gt;header.global_lock);</span></a>
<a name="875"><span class="lineNum">     875 </span><span class="lineCov">         17 :         munmap(ptr, sizeof(RegistryRegion));</span></a>
<a name="876"><span class="lineNum">     876 </span><span class="lineCov">         17 :         close(fd);</span></a>
<a name="877"><span class="lineNum">     877 </span><span class="lineCov">         17 :         int result = shm_unlink(REGISTRY_SHM_NAME);</span></a>
<a name="878"><span class="lineNum">     878 </span><span class="lineCov">         17 :         if (result == 0) {</span></a>
<a name="879"><span class="lineNum">     879 </span><span class="lineCov">         17 :             NEXUS_LOG_WARN(&quot;Registry&quot;, &quot;Force removed registry: &quot; + std::string(REGISTRY_SHM_NAME));</span></a>
<a name="880"><span class="lineNum">     880 </span><span class="lineCov">         17 :             return true;</span></a>
<a name="881"><span class="lineNum">     881 </span>            :         }</a>
<a name="882"><span class="lineNum">     882 </span><span class="lineNoCov">          0 :         return false;</span></a>
<a name="883"><span class="lineNum">     883 </span>            :     } else {</a>
<a name="884"><span class="lineNum">     884 </span>            :         // æ— æ³•è·å–é”ï¼Œè¯´æ˜æœ‰å…¶ä»–è¿›ç¨‹æ­£åœ¨ä½¿ç”¨</a>
<a name="885"><span class="lineNum">     885 </span><span class="lineCov">          2 :         munmap(ptr, sizeof(RegistryRegion));</span></a>
<a name="886"><span class="lineNum">     886 </span><span class="lineCov">          2 :         close(fd);</span></a>
<a name="887"><span class="lineNum">     887 </span><span class="lineCov">          2 :         NEXUS_LOG_ERROR(&quot;Registry&quot;, &quot;Cannot force remove: registry is in use by another process&quot;);</span></a>
<a name="888"><span class="lineNum">     888 </span><span class="lineCov">          2 :         return false;</span></a>
<a name="889"><span class="lineNum">     889 </span>            :     }</a>
<a name="890"><span class="lineNum">     890 </span>            : }</a>
<a name="891"><span class="lineNum">     891 </span>            : </a>
<a name="892"><span class="lineNum">     892 </span>            : // Private helper methods</a>
<a name="893"><span class="lineNum">     893 </span>            : </a>
<a name="894"><span class="lineNum">     894 </span><span class="lineCov">       1741 : int SharedMemoryRegistry::findEntryIndex(const std::string&amp; node_id) const {</span></a>
<a name="895"><span class="lineNum">     895 </span><span class="lineCov">     262648 :     for (size_t i = 0; i &lt; MAX_REGISTRY_ENTRIES; ++i) {</span></a>
<a name="896"><span class="lineNum">     896 </span><span class="lineCov">     261631 :         const RegistryEntry&amp; entry = registry_-&gt;entries[i];</span></a>
<a name="897"><span class="lineNum">     897 </span>            :         // ğŸ”§ For shared memory across processes, use seq_cst for cache coherence</a>
<a name="898"><span class="lineNum">     898 </span><span class="lineCov">     261631 :         uint32_t flags = entry.flags.load(std::memory_order_seq_cst);</span></a>
<a name="899"><span class="lineNum">     899 </span>            : </a>
<a name="900"><span class="lineNum">     900 </span><span class="lineCov">     261631 :         if ((flags &amp; 0x1) == 0) {  // Not valid</span></a>
<a name="901"><span class="lineNum">     901 </span><span class="lineCov">     184515 :             continue;</span></a>
<a name="902"><span class="lineNum">     902 </span>            :         }</a>
<a name="903"><span class="lineNum">     903 </span>            : </a>
<a name="904"><span class="lineNum">     904 </span>            :         // ğŸ”§ Read node_id atomically</a>
<a name="905"><span class="lineNum">     905 </span><span class="lineCov">      77116 :         std::string entry_node_id = readAtomicString(entry.node_id_atomic, NODE_ID_SIZE);</span></a>
<a name="906"><span class="lineNum">     906 </span>            : </a>
<a name="907"><span class="lineNum">     907 </span><span class="lineCov">      77116 :         if (entry_node_id == node_id) {</span></a>
<a name="908"><span class="lineNum">     908 </span><span class="lineCov">        724 :             return static_cast&lt;int&gt;(i);</span></a>
<a name="909"><span class="lineNum">     909 </span>            :         }</a>
<a name="910"><span class="lineNum">     910 </span><span class="lineCov">      77116 :     }</span></a>
<a name="911"><span class="lineNum">     911 </span><span class="lineCov">       1017 :     return -1;</span></a>
<a name="912"><span class="lineNum">     912 </span>            : }</a>
<a name="913"><span class="lineNum">     913 </span>            : </a>
<a name="914"><span class="lineNum">     914 </span><span class="lineNoCov">          0 : </span></a>
<a name="915"><span class="lineNum">     915 </span><span class="lineCov">       1280 : uint64_t SharedMemoryRegistry::getCurrentTimeMs() const {</span></a>
<a name="916"><span class="lineNum">     916 </span>            :     // ğŸ”§ CRITICAL: ä½¿ç”¨steady_clocké¿å…NTPæ—¶é’Ÿå›é€€å½±å“</a>
<a name="917"><span class="lineNum">     917 </span><span class="lineNoCov">          0 :     // è™½ç„¶steady_clockåœ¨ä¸åŒè¿›ç¨‹ä¸­epochå¯èƒ½ä¸åŒï¼Œä½†æˆ‘ä»¬ä½¿ç”¨çš„æ˜¯ç›¸å¯¹æ—¶é—´å·®</span></a>
<a name="918"><span class="lineNum">     918 </span><span class="lineNoCov">          0 :     // åªè¦åŒä¸€è¿›ç¨‹å†…çš„å¿ƒè·³æ›´æ–°å’Œæ£€æŸ¥ä½¿ç”¨åŒä¸€æ—¶é’Ÿæºå³å¯</span></a>
<a name="919"><span class="lineNum">     919 </span>            :     // æ³¨æ„ï¼šè¿™æ„å‘³ç€è¿›ç¨‹Aæ— æ³•æ£€æµ‹è¿›ç¨‹Bçš„å¿ƒè·³è¶…æ—¶ï¼ˆåªèƒ½é€šè¿‡killæ£€æµ‹å­˜æ´»ï¼‰</a>
<a name="920"><span class="lineNum">     920 </span>            :     // ä½†è¿™æ˜¯å¯æ¥å—çš„ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»æœ‰kill(pid,0)ä½œä¸ºä¸»è¦çš„å­˜æ´»æ£€æµ‹æœºåˆ¶</a>
<a name="921"><span class="lineNum">     921 </span><span class="lineCov">       1280 :     auto now = std::chrono::steady_clock::now();</span></a>
<a name="922"><span class="lineNum">     922 </span><span class="lineCov">       1280 :     auto ms = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(now.time_since_epoch());</span></a>
<a name="923"><span class="lineNum">     923 </span><span class="lineCov">       1280 :     return ms.count();</span></a>
<a name="924"><span class="lineNum">     924 </span><span class="lineCov">        272 : }</span></a>
<a name="925"><span class="lineNum">     925 </span>            : </a>
<a name="926"><span class="lineNum">     926 </span><span class="lineCov">        204 : bool SharedMemoryRegistry::isProcessAlive(pid_t pid) const {</span></a>
<a name="927"><span class="lineNum">     927 </span><span class="lineCov">        204 :     if (pid &lt;= 0) {</span></a>
<a name="928"><span class="lineNum">     928 </span><span class="lineNoCov">          0 :         return false;</span></a>
<a name="929"><span class="lineNum">     929 </span>            :     }</a>
<a name="930"><span class="lineNum">     930 </span><span class="lineCov">        476 :     return kill(pid, 0) == 0;</span></a>
<a name="931"><span class="lineNum">     931 </span><span class="lineCov">        272 : }</span></a>
<a name="932"><span class="lineNum">     932 </span><span class="lineCov">        272 : </span></a>
<a name="933"><span class="lineNum">     933 </span>            : // ğŸ”§ Atomic string helpers for cross-process safe string storage</a>
<a name="934"><span class="lineNum">     934 </span><span class="lineCov">       1856 : void SharedMemoryRegistry::writeAtomicString(std::atomic&lt;uint64_t&gt;* atomic_array, const std::string&amp; str,</span></a>
<a name="935"><span class="lineNum">     935 </span><span class="lineCov">        169 :                                              size_t max_bytes) {</span></a>
<a name="936"><span class="lineNum">     936 </span><span class="lineCov">        169 :     // Convert string to uint64_t chunks and write atomically</span></a>
<a name="937"><span class="lineNum">     937 </span><span class="lineCov">       1856 :     const size_t num_chunks = max_bytes / sizeof(uint64_t);</span></a>
<a name="938"><span class="lineNum">     938 </span><span class="lineCov">       1856 :     char buffer[max_bytes];</span></a>
<a name="939"><span class="lineNum">     939 </span><span class="lineCov">       2025 :     std::memset(buffer, 0, max_bytes);</span></a>
<a name="940"><span class="lineNum">     940 </span><span class="lineCov">       3712 :     std::strncpy(buffer, str.c_str(), max_bytes - 1);</span></a>
<a name="941"><span class="lineNum">     941 </span>            : </a>
<a name="942"><span class="lineNum">     942 </span>            :     // Write each 8-byte chunk atomically with seq_cst for immediate visibility</a>
<a name="943"><span class="lineNum">     943 </span><span class="lineCov">      16829 :     for (size_t i = 0; i &lt; num_chunks; ++i) {</span></a>
<a name="944"><span class="lineNum">     944 </span>            :         uint64_t chunk;</a>
<a name="945"><span class="lineNum">     945 </span><span class="lineCov">      14848 :         std::memcpy(&amp;chunk, buffer + i * sizeof(uint64_t), sizeof(uint64_t));</span></a>
<a name="946"><span class="lineNum">     946 </span><span class="lineCov">      14973 :         atomic_array[i].store(chunk, std::memory_order_seq_cst);</span></a>
<a name="947"><span class="lineNum">     947 </span><span class="lineCov">        125 :     }</span></a>
<a name="948"><span class="lineNum">     948 </span><span class="lineCov">       1981 : }</span></a>
<a name="949"><span class="lineNum">     949 </span><span class="lineCov">        250 : </span></a>
<a name="950"><span class="lineNum">     950 </span><span class="lineCov">      78174 : std::string SharedMemoryRegistry::readAtomicString(const std::atomic&lt;uint64_t&gt;* atomic_array, size_t max_bytes) {</span></a>
<a name="951"><span class="lineNum">     951 </span>            :     // Read uint64_t chunks atomically and convert to string</a>
<a name="952"><span class="lineNum">     952 </span><span class="lineCov">      79299 :     const size_t num_chunks = max_bytes / sizeof(uint64_t);</span></a>
<a name="953"><span class="lineNum">     953 </span><span class="lineCov">      78174 :     char buffer[max_bytes];</span></a>
<a name="954"><span class="lineNum">     954 </span><span class="lineCov">      79174 :     std::memset(buffer, 0, max_bytes);  // ğŸ”§ åˆå§‹åŒ–ä¸ºå…¨0ï¼Œç¡®ä¿å®‰å…¨</span></a>
<a name="955"><span class="lineNum">     955 </span><span class="lineCov">       1000 : </span></a>
<a name="956"><span class="lineNum">     956 </span>            :     // Read each 8-byte chunk atomically with seq_cst</a>
<a name="957"><span class="lineNum">     957 </span><span class="lineCov">     703691 :     for (size_t i = 0; i &lt; num_chunks; ++i) {</span></a>
<a name="958"><span class="lineNum">     958 </span><span class="lineCov">     625392 :         uint64_t chunk = atomic_array[i].load(std::memory_order_seq_cst);</span></a>
<a name="959"><span class="lineNum">     959 </span><span class="lineCov">     688744 :         std::memcpy(buffer + i * sizeof(uint64_t), &amp;chunk, sizeof(uint64_t));</span></a>
<a name="960"><span class="lineNum">     960 </span>            :     }</a>
<a name="961"><span class="lineNum">     961 </span><span class="lineCov">      63352 : </span></a>
<a name="962"><span class="lineNum">     962 </span><span class="lineCov">     141526 :     buffer[max_bytes - 1] = '\0';  // Ensure null termination</span></a>
<a name="963"><span class="lineNum">     963 </span><span class="lineCov">      63352 : </span></a>
<a name="964"><span class="lineNum">     964 </span>            :     // ğŸ”§ CRITICAL: ä½¿ç”¨ strnlen è€Œä¸æ˜¯ä¾èµ– null terminator</a>
<a name="965"><span class="lineNum">     965 </span>            :     // é˜²æ­¢è¯»åˆ°æŸåæ•°æ®æ—¶è¶Šç•Œè®¿é—®</a>
<a name="966"><span class="lineNum">     966 </span><span class="lineCov">     648342 :     size_t len = strnlen(buffer, max_bytes - 1);</span></a>
<a name="967"><span class="lineNum">     967 </span><span class="lineCov">     584990 :     return std::string(buffer, len);</span></a>
<a name="968"><span class="lineNum">     968 </span><span class="lineCov">     584990 : }</span></a>
<a name="969"><span class="lineNum">     969 </span>            : </a>
<a name="970"><span class="lineNum">     970 </span>            : }  // namespace rpc</a>
<a name="971"><span class="lineNum">     971 </span><span class="lineCov">      63352 : }  // namespace Nexus</span></a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
