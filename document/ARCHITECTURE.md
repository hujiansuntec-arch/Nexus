# Nexus æ¶æ„è®¾è®¡æ–‡æ¡£

**ç‰ˆæœ¬**: 3.0  
**æ—¥æœŸ**: 2025-11-28  
**ä½œè€…**: Nexus Team

> **ğŸ“ æœ€æ–°æ›´æ–° (2025-11-28)**:
> - âœ… ç§»é™¤FIFOæ–¹æ¡ˆï¼Œç®€åŒ–ä¸ºCV + SemaphoreåŒæœºåˆ¶
> - âœ… æ‰¹é‡é€šçŸ¥ä¼˜åŒ–ï¼šCPUä»8.6%é™åˆ°5.7%ï¼ˆâ¬‡ï¸34%ï¼‰
> - âœ… ç¼“å­˜æ´»è·ƒé˜Ÿåˆ—ï¼šå‡å°‘90%éå†å¼€é”€
> - âœ… è‡ªé€‚åº”è¶…æ—¶ï¼šç©ºé—²50msã€ç¹å¿™5msåŠ¨æ€åˆ‡æ¢
> - âœ… Flagså®‰å…¨éªŒè¯ï¼šåŒé‡ä¿æŠ¤æœºåˆ¶
> - ğŸ“– è¯¦ç»†è®¾è®¡è¯·å‚è€ƒ [DESIGN_DOC.md](DESIGN_DOC.md)

---

## ç›®å½•

1. [æ¦‚è¿°](#1-æ¦‚è¿°)
2. [æ•´ä½“æ¶æ„](#2-æ•´ä½“æ¶æ„)
3. [ä¼ è¾“å±‚è®¾è®¡](#3-ä¼ è¾“å±‚è®¾è®¡)
4. [Nodeæ³¨å†Œä¸è¿æ¥](#4-nodeæ³¨å†Œä¸è¿æ¥)
5. [æœåŠ¡å‘ç°æœºåˆ¶](#5-æœåŠ¡å‘ç°æœºåˆ¶)
6. [é€šçŸ¥æœºåˆ¶å¯¹æ¯”](#6-é€šçŸ¥æœºåˆ¶å¯¹æ¯”)
7. [èµ„æºç®¡ç†](#7-èµ„æºç®¡ç†)
8. [æ€§èƒ½ä¼˜åŒ–](#8-æ€§èƒ½ä¼˜åŒ–)
9. [è®¾è®¡æƒè¡¡](#9-è®¾è®¡æƒè¡¡)

---

## 1. æ¦‚è¿°

### 1.1 è®¾è®¡ç›®æ ‡

Nexus æ˜¯ä¸€ä¸ªé«˜æ€§èƒ½è¿›ç¨‹é—´é€šä¿¡æ¡†æ¶ï¼Œè®¾è®¡ç›®æ ‡åŒ…æ‹¬ï¼š

| ç›®æ ‡ | æŒ‡æ ‡ | å®ç°æ–¹å¼ |
|-----|------|---------|
| **ä½å»¶è¿Ÿ** | <10Î¼sï¼ˆå…±äº«å†…å­˜ï¼‰ | æ— é”é˜Ÿåˆ— + é›¶æ‹·è´ |
| **ä½CPUå ç”¨** | <6%ï¼ˆ1000 msg/sï¼‰ | æ‰¹é‡é€šçŸ¥ + è‡ªé€‚åº”è¶…æ—¶ |
| **é«˜åå** | >100 MB/sï¼ˆå¤§æ•°æ®ï¼‰ | ç¯å½¢ç¼“å†²åŒº + æ‰¹é‡ä¼ è¾“ |
| **å¯æ‰©å±•** | æ— èŠ‚ç‚¹æ•°é‡é™åˆ¶ | åŠ¨æ€å†…å­˜åˆ†é… |
| **é«˜å¯ç”¨** | å¼‚å¸¸é€€å‡ºæ¢å¤ | PIDæ£€æµ‹ + å¼•ç”¨è®¡æ•° + å¿ƒè·³ |
| **æ˜“ç”¨æ€§** | ç®€æ´API | å‘å¸ƒ-è®¢é˜…æ¨¡å¼ |
| **ä½å†…å­˜** | 40MB/èŠ‚ç‚¹ï¼ˆé»˜è®¤ï¼‰ | 64é˜Ÿåˆ—é…ç½® + MAP_NORESERVE |

### 1.2 æ ¸å¿ƒç‰¹æ€§

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Nexus æ ¸å¿ƒç‰¹æ€§ (v3.0)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  âœ“ é›¶æ‹·è´å…±äº«å†…å­˜ä¼ è¾“ï¼ˆåŠ¨æ€SPSCé˜Ÿåˆ—ï¼‰                 â”‚
â”‚  âœ“ åŒé€šçŸ¥æœºåˆ¶ï¼ˆCV 5.7% + Semaphore 5.9%ï¼‰           â”‚
â”‚  âœ“ æ‰¹é‡é€šçŸ¥ä¼˜åŒ–ï¼ˆ0â†’1è§¦å‘ï¼Œå‡å°‘60%å”¤é†’ï¼‰               â”‚
â”‚  âœ“ å†…å­˜ä¼˜åŒ–ï¼ˆ529MB â†’ 40MBï¼Œé™ä½92%ï¼‰                â”‚
â”‚  âœ“ è·¨å¹³å°æ”¯æŒï¼ˆLinux + QNXï¼‰                        â”‚
â”‚  âœ“ åŠ¨æ€èŠ‚ç‚¹å‘ç°ï¼ˆåŸºäºRegistryï¼‰                      â”‚
â”‚  âœ“ ä¸‰é‡æ¸…ç†æœºåˆ¶ï¼ˆå¼•ç”¨è®¡æ•° + PID + å¿ƒè·³ï¼‰              â”‚
â”‚  âœ“ CRC32æ•°æ®å®Œæ•´æ€§æ ¡éªŒ                               â”‚
â”‚  âœ“ æµæ§æœºåˆ¶ï¼ˆèƒŒå‹ä¿æŠ¤ï¼‰                              â”‚
â”‚  âœ“ å‘å¸ƒ-è®¢é˜…æ¨¡å¼ï¼ˆä¸»é¢˜åˆ†ç»„ï¼‰                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. æ•´ä½“æ¶æ„

### 2.1 åˆ†å±‚æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Application Layer                         â”‚
â”‚                                                               â”‚
â”‚   Node::publish()  |  Node::subscribe()  |  sendLargeData() â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Node Layer                              â”‚
â”‚                                                               â”‚
â”‚  â€¢ Message routing (topic-based)                             â”‚
â”‚  â€¢ Callback management                                       â”‚
â”‚  â€¢ Transport selection (inprocess vs shared memory)          â”‚
â”‚  â€¢ Node discovery (via Registry)                             â”‚
â”‚  â€¢ Heartbeat monitoring (NODE_LEFT event)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                    â”‚                    â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  InProcess       â”‚  â”‚  SharedMemory  â”‚  â”‚  LargeData       â”‚
â”‚  Transport       â”‚  â”‚  V3 Transport  â”‚  â”‚  Channel         â”‚
â”‚                  â”‚  â”‚                â”‚  â”‚                  â”‚
â”‚  â€¢ Direct call   â”‚  â”‚  â€¢ SPSC queue  â”‚  â”‚  â€¢ Ring buffer   â”‚
â”‚  â€¢ No overhead   â”‚  â”‚  â€¢ Dynamic     â”‚  â”‚  â€¢ Zero-copy     â”‚
â”‚  â€¢ <1Î¼s          â”‚  â”‚  â€¢ <10Î¼s       â”‚  â”‚  â€¢ 135 MB/s      â”‚
â”‚                  â”‚  â”‚  â€¢ 40MB/node   â”‚  â”‚  â€¢ 64MB buffer   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                   â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
            â”‚   Registry   â”‚    â”‚   Node SHM   â”‚
            â”‚ (Discovery)  â”‚    â”‚  (RX Queue)  â”‚
            â”‚              â”‚    â”‚              â”‚
            â”‚  /dev/shm/   â”‚    â”‚  /dev/shm/   â”‚
            â”‚  librpc_     â”‚    â”‚  librpc_node_â”‚
            â”‚  registry    â”‚    â”‚  <pid>_<hash>â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ç»„ä»¶èŒè´£

| ç»„ä»¶ | èŒè´£ | æ–‡ä»¶ |
|-----|------|------|
| **Node** | æ¶ˆæ¯è·¯ç”±ã€è®¢é˜…ç®¡ç†ã€ä¼ è¾“é€‰æ‹©ã€å¿ƒè·³é›†æˆ | Node.h, NodeImpl.cpp |
| **InProcess Transport** | è¿›ç¨‹å†…é€šä¿¡ï¼ˆç›´æ¥è°ƒç”¨ï¼‰ | NodeImpl.cpp |
| **SharedMemory V3** | è·¨è¿›ç¨‹å°æ¶ˆæ¯ä¼ è¾“ã€å¿ƒè·³ç›‘æ§ | SharedMemoryTransportV3.cpp |
| **LargeDataChannel** | å¤§æ•°æ®ä¸“ç”¨é€šé“ | LargeDataChannel.cpp |
| **Registry** | èŠ‚ç‚¹æ³¨å†Œä¸å‘ç° | SharedMemoryRegistry.cpp |
| **LockFreeQueue** | æ— é”ç¯å½¢é˜Ÿåˆ— | LockFreeQueue.h |

---

## 3. ä¼ è¾“å±‚è®¾è®¡

### 3.1 InProcess Transport

**é€‚ç”¨åœºæ™¯**ï¼šåŒè¿›ç¨‹å†…çš„èŠ‚ç‚¹é€šä¿¡

**è®¾è®¡**ï¼š
```cpp
class NodeImpl {
    std::map<std::string, std::shared_ptr<NodeImpl>> inprocess_nodes_;
    
    void publish(...) {
        for (auto& [node_id, node] : inprocess_nodes_) {
            // ç›´æ¥è°ƒç”¨å›è°ƒï¼Œæ— åºåˆ—åŒ–
            node->dispatchMessage(topic, data, size);
        }
    }
};
```

**ä¼˜ç‚¹**ï¼š
- âœ… é›¶å¼€é”€ï¼ˆç›´æ¥å‡½æ•°è°ƒç”¨ï¼‰
- âœ… æ— åºåˆ—åŒ–
- âœ… å»¶è¿Ÿ <1Î¼s

**ç¼ºç‚¹**ï¼š
- âŒ ä»…é™åŒè¿›ç¨‹

---

### 3.2 SharedMemory V3 Transport

**é€‚ç”¨åœºæ™¯**ï¼šè·¨è¿›ç¨‹å°æ¶ˆæ¯ä¼ è¾“ï¼ˆ<256KBï¼‰

#### 3.2.1 æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  /dev/shm/librpc_registry              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Node0: "app_A" -> /librpc_node_12345_abc123    â”‚  â”‚
â”‚  â”‚  Node1: "app_B" -> /librpc_node_67890_def456    â”‚  â”‚
â”‚  â”‚  ...                                             â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â–²
                       â”‚ (lookup + heartbeat)
                       â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ /dev/shm/            â”‚      â”‚ /dev/shm/            â”‚
â”‚ librpc_node_12345_   â”‚      â”‚ librpc_node_67890_   â”‚
â”‚ abc123               â”‚      â”‚ def456               â”‚
â”‚                      â”‚      â”‚                      â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ NodeHeader       â”‚ â”‚      â”‚ â”‚ NodeHeader       â”‚ â”‚
â”‚ â”‚  â€¢ magic         â”‚ â”‚      â”‚ â”‚  â€¢ magic         â”‚ â”‚
â”‚ â”‚  â€¢ version       â”‚ â”‚      â”‚ â”‚  â€¢ version       â”‚ â”‚
â”‚ â”‚  â€¢ owner_pid âœ“   â”‚ â”‚      â”‚ â”‚  â€¢ owner_pid âœ“   â”‚ â”‚
â”‚ â”‚  â€¢ heartbeat âœ“   â”‚ â”‚      â”‚ â”‚  â€¢ heartbeat âœ“   â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚      â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                      â”‚      â”‚                      â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ InboundQueue[0]  â”‚ â”‚      â”‚ â”‚ InboundQueue[0]  â”‚ â”‚
â”‚ â”‚  from: "app_B"   â”‚ â”‚      â”‚ â”‚  from: "app_A"   â”‚ â”‚
â”‚ â”‚  queue: SPSC     â”‚ â”‚      â”‚ â”‚  queue: SPSC     â”‚ â”‚
â”‚ â”‚  (256 slots)     â”‚ â”‚      â”‚ â”‚  (256 slots)     â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚      â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ â”‚ InboundQueue[1]  â”‚ â”‚      â”‚ â”‚ InboundQueue[1]  â”‚ â”‚
â”‚ â”‚  ...             â”‚ â”‚      â”‚ â”‚  ...             â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚      â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ [æœ€å¤š32ä¸ªé˜Ÿåˆ—]        â”‚      â”‚ [æœ€å¤š32ä¸ªé˜Ÿåˆ—]        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 3.2.2 æ•°æ®ç»“æ„ï¼ˆä¼˜åŒ–åï¼‰

```cpp
// èŠ‚ç‚¹å…±äº«å†…å­˜å¸ƒå±€ï¼ˆv3.0ä¼˜åŒ–ï¼‰
struct NodeSharedMemory {
    NodeHeader header;
    InboundQueue queues[max_inbound_queues];  // é»˜è®¤32ï¼Œæœ€å¤§64
};

// èŠ‚ç‚¹å¤´éƒ¨
struct NodeHeader {
    std::atomic<uint32_t> magic;           // é­”æ•°ï¼ˆéªŒè¯ï¼‰
    std::atomic<uint32_t> version;         // ç‰ˆæœ¬å·
    std::atomic<uint32_t> num_queues;      // æ´»è·ƒé˜Ÿåˆ—æ•°
    std::atomic<uint32_t> max_queues;      // æœ€å¤§é˜Ÿåˆ—æ•°
    std::atomic<uint64_t> last_heartbeat;  // å¿ƒè·³æ—¶é—´æˆ³ âœ“
    std::atomic<bool> ready;               // å°±ç»ªæ ‡å¿—
    std::atomic<int32_t> owner_pid;        // è¿›ç¨‹PID âœ“
    char padding[31];
} __attribute__((aligned(64)));

// å…¥ç«™é˜Ÿåˆ—ï¼ˆä»æŸä¸ªå‘é€è€…æ¥æ”¶ï¼‰
struct InboundQueue {
    char sender_id[64];                         // å‘é€è€…ID
    std::atomic<uint32_t> flags;                // æ ‡å¿—ä½
    LockFreeRingBuffer<QUEUE_CAPACITY> queue;   // æ— é”é˜Ÿåˆ—ï¼ˆ256ï¼‰
    std::atomic<uint32_t> congestion_level;     // æ‹¥å¡ç­‰çº§
    std::atomic<uint64_t> drop_count;           // ä¸¢åŒ…è®¡æ•°
    char padding[56];
} __attribute__((aligned(64)));
```

#### 3.2.3 å†…å­˜ä¼˜åŒ–å†ç¨‹

| ç‰ˆæœ¬ | QUEUE_CAPACITY | MAX_INBOUND_QUEUES | é»˜è®¤é˜Ÿåˆ—æ•° | å†…å­˜å ç”¨ | ä¼˜åŒ– |
|------|---------------|-------------------|-----------|---------|------|
| **v2.5** | 1024 | 256 | 256 | **529 MB** | åŸºå‡† |
| **v2.6** | 256 | 256 | 256 | 132 MB | â†“ 75% |
| **v2.7** | 256 | 64 | 64 | 33 MB | â†“ 94% |
| **v3.0** | 256 | 64 | **32** | **33 MB** | âœ“ æœ€ç»ˆ |

**ä¼˜åŒ–ç­–ç•¥**ï¼š
1. é™ä½é˜Ÿåˆ—å®¹é‡ï¼š1024 â†’ 256ï¼ˆå•é˜Ÿåˆ— 2MB â†’ 0.5MBï¼‰
2. é™åˆ¶æœ€å¤§é˜Ÿåˆ—æ•°ï¼š256 â†’ 64ï¼ˆæœ€å¤§132MB â†’ 40MBï¼‰
3. é»˜è®¤é˜Ÿåˆ—æ•°ï¼š64 â†’ 32ï¼ˆæŒ‰éœ€åˆ›å»ºï¼Œé»˜è®¤å ç”¨æ›´å°ï¼‰

#### 3.2.4 å¿ƒè·³æœºåˆ¶ä¸NODE_LEFTé›†æˆ

**å¿ƒè·³ç›‘æ§çº¿ç¨‹**ï¼š
```cpp
void SharedMemoryTransportV3::heartbeatLoop() {
    while (running_) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        
        // 1. æ›´æ–°è‡ªå·±çš„å¿ƒè·³
        header_->last_heartbeat.store(getCurrentTimestamp());
        
        // 2. æ£€æŸ¥æ‰€æœ‰å·²çŸ¥èŠ‚ç‚¹çš„å¿ƒè·³
        size_t cleaned = 0;
        for (auto it = node_shm_map_.begin(); it != node_shm_map_.end();) {
            uint64_t last_hb = it->second.header->last_heartbeat.load();
            uint64_t now = getCurrentTimestamp();
            
            // è¶…æ—¶5ç§’
            if (now - last_hb > 5000) {
                std::cout << "[ShmV3] Node timeout: " << it->first 
                          << ", last heartbeat: " << (now - last_hb) << "ms ago"
                          << std::endl;
                
                // æ¸…ç†èŠ‚ç‚¹
                cleanupNodeConnection(it->second);
                it = node_shm_map_.erase(it);
                cleaned++;
            } else {
                ++it;
            }
        }
        
        // 3. âœ“ è§¦å‘NODE_LEFTäº‹ä»¶ï¼ˆé›†æˆæœåŠ¡å‘ç°ï¼‰
        if (cleaned > 0 && node_impl_) {
            for (const auto& node_id : cleaned_nodes) {
                node_impl_->handleNodeEvent(node_id, false);  // false = left
            }
        }
    }
}
```

**é›†æˆæ•ˆæœ**ï¼š
- âœ… å´©æºƒèŠ‚ç‚¹2-5ç§’å†…è‡ªåŠ¨æ¸…ç†
- âœ… æœåŠ¡å‘ç°è‡ªåŠ¨æ›´æ–°ï¼ˆç§»é™¤å¤±æ•ˆèŠ‚ç‚¹ï¼‰
- âœ… è®¢é˜…è€…åˆ—è¡¨è‡ªåŠ¨ç»´æŠ¤

#### 3.2.5 æ€§èƒ½ç‰¹æ€§ï¼ˆv3.0ï¼‰

| ç‰¹æ€§ | å€¼ | è¯´æ˜ |
|-----|---|------|
| **é˜Ÿåˆ—å®¹é‡** | 256æ¡æ¶ˆæ¯ | å¯é…ç½®64-1024 |
| **æœ€å¤§å…¥ç«™é˜Ÿåˆ—** | 64ä¸ª | ç¡¬ç¼–ç ä¸Šé™ |
| **é»˜è®¤é˜Ÿåˆ—æ•°** | 32ä¸ª | å¯é…ç½®8-64 |
| **å»¶è¿Ÿ** | 8Î¼s (P50) | æ— é”é˜Ÿåˆ— |
| **åå** | ~50 MB/s | 256å­—èŠ‚æ¶ˆæ¯ |
| **å†…å­˜å ç”¨** | **40MB/èŠ‚ç‚¹** | ä¼˜åŒ–92% âœ“ |
| **å¿ƒè·³é—´éš”** | 1ç§’ | åå°çº¿ç¨‹ |
| **è¶…æ—¶æ£€æµ‹** | 5ç§’ | è‡ªåŠ¨æ¸…ç† |

---

### 3.3 LargeDataChannel

**é€‚ç”¨åœºæ™¯**ï¼šé«˜é¢‘å¤§æ•°æ®ä¼ è¾“ï¼ˆ>1MBï¼Œæœ€å¤§8MBï¼‰

#### 3.3.1 æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         /dev/shm/camera_channel (64MB)                 â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  RingBufferControl                               â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚ write_pos, read_pos, sequence              â”‚  â”‚  â”‚
â”‚  â”‚  â”‚ writer_heartbeat, reader_heartbeat         â”‚  â”‚  â”‚
â”‚  â”‚  â”‚ ref_count âœ“                                â”‚  â”‚  â”‚
â”‚  â”‚  â”‚ writer_pid âœ“, reader_pid âœ“                â”‚  â”‚  â”‚
â”‚  â”‚  â”‚ capacity, max_block_size                   â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Ring Buffer (64MB - sizeof(Control))           â”‚  â”‚
â”‚  â”‚                                                  â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚  â”‚
â”‚  â”‚  â”‚ Block1 â”‚â†’ â”‚ Block2 â”‚â†’ â”‚ Block3 â”‚  ...       â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚  â”‚
â”‚  â”‚                                                  â”‚  â”‚
â”‚  â”‚  Each block:                                    â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚ LargeDataHeader                          â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â€¢ size, sequence, crc32, timestamp      â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â€¢ topic                                 â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚ Payload data (variable length)          â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 3.3.2 æ•°æ®ç»“æ„

```cpp
// ç¯å½¢ç¼“å†²åŒºæ§åˆ¶å—
struct RingBufferControl {
    std::atomic<uint64_t> write_pos;         // å†™ä½ç½®
    std::atomic<uint64_t> read_pos;          // è¯»ä½ç½®
    std::atomic<uint64_t> sequence;          // åºåˆ—å·
    std::atomic<uint64_t> reader_heartbeat;  // è¯»ç«¯å¿ƒè·³
    std::atomic<uint64_t> writer_heartbeat;  // å†™ç«¯å¿ƒè·³
    std::atomic<int32_t> ref_count;          // å¼•ç”¨è®¡æ•° âœ“
    std::atomic<int32_t> reader_pid;         // è¯»ç«¯PID âœ“
    std::atomic<int32_t> writer_pid;         // å†™ç«¯PID âœ“
    uint64_t capacity;                       // ç¼“å†²åŒºå®¹é‡
    uint32_t max_block_size;                 // æœ€å¤§å—å¤§å°
    uint32_t reserved;
} __attribute__((aligned(64)));

// æ•°æ®å—å¤´éƒ¨
struct LargeDataHeader {
    uint64_t size;          // æ•°æ®å¤§å°
    uint64_t sequence;      // åºåˆ—å·
    uint64_t timestamp;     // æ—¶é—´æˆ³
    uint32_t crc32;         // CRC32æ ¡éªŒ âœ“
    char topic[64];         // ä¸»é¢˜åç§°
    char reserved[36];
} __attribute__((aligned(64)));
```

#### 3.3.3 é›¶æ‹·è´è¯»å–

**ä¼ ç»Ÿæ‹·è´æ–¹å¼**ï¼ˆ2æ¬¡æ‹·è´ï¼‰ï¼š
```
Shared Memory â†’ Temp Buffer â†’ Application Buffer
     (copy 1)        (copy 2)
```

**é›¶æ‹·è´æ–¹å¼**ï¼ˆ0æ¬¡æ‹·è´ï¼‰ï¼š
```cpp
DataBlock block;
if (channel->tryRead(block)) {
    // block.data ç›´æ¥æŒ‡å‘å…±äº«å†…å­˜
    // æ— æ‹·è´ï¼Œç›´æ¥è®¿é—®ï¼âœ“
    processData(block.data, block.header.size);
    
    // å¤„ç†å®Œåé‡Šæ”¾
    channel->releaseBlock(block);
}
```

#### 3.3.4 æµæ§æœºåˆ¶

```cpp
int64_t write(const uint8_t* data, size_t size) {
    // æ£€æŸ¥å¯ç”¨ç©ºé—´
    uint64_t available = capacity - (write_pos - read_pos);
    
    if (total_size > available) {
        // é˜Ÿåˆ—æ»¡ï¼Œæ£€æŸ¥è¯»ç«¯æ˜¯å¦å­˜æ´»
        if (readerDeadFor(30)) {
            // è¯»ç«¯å·²æ­»ï¼Œé‡ç½®é˜Ÿåˆ—
            read_pos.store(write_pos.load());
        } else {
            // è¿”å›è¶…æ—¶é”™è¯¯ï¼Œåº”ç”¨å±‚é‡è¯•
            return -1;  // TIMEOUT
        }
    }
    
    // å†™å…¥æ•°æ®...
}
```

#### 3.3.5 æ€§èƒ½ç‰¹æ€§

| ç‰¹æ€§ | å€¼ | è¯´æ˜ |
|-----|---|------|
| **ç¼“å†²åŒºå¤§å°** | 64MBï¼ˆé»˜è®¤ï¼‰ | å¯é…ç½®128/256MB |
| **æœ€å¤§å—å¤§å°** | 8MB | å•æ¬¡ä¼ è¾“ä¸Šé™ |
| **å»¶è¿Ÿ** | 35Î¼s (P50, 1MB) | é›¶æ‹·è´è¯»å– |
| **åå** | ~135 MB/s | 1MBå— |
| **CRCæ ¡éªŒ** | CRC32 | æ•°æ®å®Œæ•´æ€§ âœ“ |

---

## 4. é€šçŸ¥æœºåˆ¶å¯¹æ¯”

### 4.1 æ”¯æŒçš„é€šçŸ¥æœºåˆ¶

LibRPC V3.0 æ”¯æŒä¸¤ç§é«˜æ€§èƒ½é€šçŸ¥æœºåˆ¶ï¼š

| æœºåˆ¶ | CPUå ç”¨ | ä¸¢åŒ…ç‡ | ä¼˜ç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|---------|--------|------|---------|
| **Condition Variable** | **5.7%** âœ… | 0.027% | è·¨å¹³å°é€šç”¨ï¼ŒPOSIXæ ‡å‡† | é€šç”¨Linux/QNXç³»ç»Ÿ |
| **Semaphore** | **5.9%** âœ… | 0% | æ— mutexå¼€é”€ï¼Œç•¥ç®€å• | QNXåµŒå…¥å¼ç³»ç»Ÿ |

> **å·²ç§»é™¤**ï¼šFIFO+epollæ–¹æ¡ˆï¼ˆCPU 5%ä½†ä¸¢åŒ…ç‡0.06%ï¼Œå¯é æ€§é—®é¢˜ï¼‰

### 4.2 Condition Variable æ–¹æ¡ˆ

**æ ¸å¿ƒè®¾è®¡**ï¼š

```cpp
// å‘é€ç«¯ï¼šæ‰¹é‡é€šçŸ¥ä¼˜åŒ–
uint32_t prev = queue->pending_msgs.fetch_add(1, 
                    std::memory_order_release);
if (prev == 0) {
    // åªåœ¨ 0â†’1 æ—¶è§¦å‘é€šçŸ¥ï¼Œé¿å…è¿‡åº¦å”¤é†’
    pthread_cond_signal(&queue->notify_cond);
}

// æ¥æ”¶ç«¯ï¼šçœŸæ­£çš„é˜»å¡ç­‰å¾…
pthread_mutex_lock(&wait_queue->notify_mutex);

// åŒé‡æ£€æŸ¥é¿å…ä¿¡å·ä¸¢å¤±
if (wait_queue->pending_msgs.load(std::memory_order_acquire) == 0) {
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    ts.tv_nsec += timeout_ms * 1000000;  // è‡ªé€‚åº”è¶…æ—¶
    if (ts.tv_nsec >= 1000000000) {
        ts.tv_sec++;
        ts.tv_nsec -= 1000000000;
    }
    
    // é˜»å¡ç­‰å¾…ï¼ˆéè½®è¯¢ï¼‰
    pthread_cond_timedwait(&wait_queue->notify_cond, 
                           &wait_queue->notify_mutex, &ts);
}

pthread_mutex_unlock(&wait_queue->notify_mutex);
```

**ä¼˜åŒ–è¦ç‚¹**ï¼š
- âœ… **æ‰¹é‡é€šçŸ¥**ï¼špending_msgs ä» 0â†’1 æ‰ signalï¼ˆå‡å°‘60%å”¤é†’ï¼‰
- âœ… **åŒé‡æ£€æŸ¥**ï¼šé¿å…ä¿¡å·ä¸¢å¤±
- âœ… **è‡ªé€‚åº”è¶…æ—¶**ï¼šç©ºé—²50msã€ç¹å¿™5ms
- âœ… **çœŸæ­£ç­‰å¾…**ï¼špthread_cond_timedwaitï¼ˆéè½®è¯¢ï¼‰

### 4.3 Semaphore æ–¹æ¡ˆ

**æ ¸å¿ƒè®¾è®¡**ï¼š

```cpp
// å‘é€ç«¯ï¼šæ‰¹é‡é€šçŸ¥ä¼˜åŒ–ï¼ˆåŒCVï¼‰
uint32_t prev = queue->pending_msgs.fetch_add(1, 
                    std::memory_order_release);
if (prev == 0) {
    sem_post(&queue->notify_sem);  // åªåœ¨ 0â†’1 æ—¶é€šçŸ¥
}

// æ¥æ”¶ç«¯ï¼šçœŸæ­£çš„é˜»å¡ç­‰å¾…
struct timespec timeout;
clock_gettime(CLOCK_REALTIME, &timeout);
timeout.tv_nsec += timeout_ms * 1000000L;
if (timeout.tv_nsec >= 1000000000) {
    timeout.tv_sec++;
    timeout.tv_nsec -= 1000000000;
}

// é˜»å¡ç­‰å¾…ï¼ˆéè½®è¯¢ï¼‰
sem_timedwait(&active_queues[0]->notify_sem, &timeout);
```

**ä¼˜åŒ–è¦ç‚¹**ï¼š
- âœ… **æ‰¹é‡é€šçŸ¥**ï¼šåŒCVæ–¹æ¡ˆ
- âœ… **çœŸæ­£ç­‰å¾…**ï¼šsem_timedwaitï¼ˆéè½®è¯¢ï¼‰
- âœ… **è‡ªé€‚åº”è¶…æ—¶**ï¼šåŒCVæ–¹æ¡ˆ
- âœ… **æ— mutexå¼€é”€**ï¼šç›¸æ¯”CVç•¥ç®€å•

### 4.4 æ€§èƒ½å¯¹æ¯”ï¼ˆ1000 msg/sè´Ÿè½½ï¼‰

| æ–¹æ¡ˆ | node0 CPU | node1 CPU | å¹³å‡CPU | ä¸¢åŒ…ç‡ | ä¼˜åŠ¿ |
|------|-----------|-----------|---------|--------|------|
| **CVæ–¹æ¡ˆ** | 5.4% | 6.0% | **5.7%** âœ… | 0.027% | é€šç”¨æ€§æœ€å¥½ |
| **Semaphore** | 5.8% | 6.0% | **5.9%** âœ… | 0% | QNXåŸç”Ÿæ”¯æŒ |
| FIFO+epollï¼ˆå·²ç§»é™¤ï¼‰ | 4.8% | 5.2% | 5.0% âŒ | 0.06% | å¯é æ€§é—®é¢˜ |

**ä¼˜åŒ–æ•ˆæœ**ï¼š
- CPUå ç”¨ä»ä¼˜åŒ–å‰8.6%é™åˆ°5.7%ï¼ˆâ¬‡ï¸**34%**ï¼‰
- å‡å°‘60%çš„å”¤é†’æ“ä½œ
- ä¸¢åŒ…ç‡<0.1%ï¼ˆé«˜å¯é ï¼‰

### 4.5 ç¼“å­˜æ´»è·ƒé˜Ÿåˆ—ä¼˜åŒ–

**é—®é¢˜**ï¼šæ¯æ¬¡å¾ªç¯éå†æ‰€æœ‰ MAX_INBOUND_QUEUESï¼ˆ64ä¸ªï¼‰

**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼š

```cpp
std::vector<InboundQueue*> active_queues;  // ç¼“å­˜æ´»è·ƒé˜Ÿåˆ—
uint32_t cached_num_queues = 0;
int queue_refresh_counter = 0;

// æ£€æµ‹num_queueså˜åŒ–æ—¶æ‰åˆ·æ–°
uint32_t current = my_shm_->header.num_queues.load();
if (current != cached_num_queues || 
    queue_refresh_counter >= 100 ||  // å®šæœŸåˆ·æ–°
    active_queues.empty()) {
    
    active_queues.clear();
    for (uint32_t i = 0; i < MAX_INBOUND_QUEUES; ++i) {
        InboundQueue& q = my_shm_->queues[i];
        uint32_t flags = q.flags.load(std::memory_order_relaxed);
        if ((flags & 0x3) == 0x3) {  // valid + active
            active_queues.push_back(&q);
        }
    }
    cached_num_queues = current;
    queue_refresh_counter = 0;
}

// ä»…éå†æ´»è·ƒé˜Ÿåˆ—ï¼ˆå®‰å…¨éªŒè¯ï¼‰
for (auto* q : active_queues) {
    // æ¯æ¬¡è®¿é—®å‰éªŒè¯flags
    uint32_t flags = q->flags.load(std::memory_order_relaxed);
    if ((flags & 0x3) != 0x3) {
        continue;  // è·³è¿‡å¤±æ•ˆé˜Ÿåˆ—
    }
    
    // æ‰¹é‡å¤„ç†æ¶ˆæ¯
    processMessages(q);
}
```

**æ•ˆæœ**ï¼š
- âœ… å‡å°‘90%çš„é˜Ÿåˆ—éå†
- âœ… é™ä½atomic loadæ“ä½œ
- âœ… åŒé‡ä¿æŠ¤ï¼ˆnum_queuesæ£€æµ‹ + flagséªŒè¯ï¼‰

---

## 4. Nodeæ³¨å†Œä¸è¿æ¥

### 4.1 Registryæ¶æ„

**SharedMemoryRegistry** æ˜¯å…¨å±€èŠ‚ç‚¹æ³¨å†Œè¡¨ï¼Œæ‰€æœ‰è·¨è¿›ç¨‹èŠ‚ç‚¹å…±äº«ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        /dev/shm/librpc_registry (å…±äº«å†…å­˜)          â”‚
â”‚                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Header                                        â”‚ â”‚
â”‚  â”‚  â€¢ magic: 0x4C525247 ("LRRG")                 â”‚ â”‚
â”‚  â”‚  â€¢ version: 1                                  â”‚ â”‚
â”‚  â”‚  â€¢ num_entries: å½“å‰èŠ‚ç‚¹æ•°                     â”‚ â”‚
â”‚  â”‚  â€¢ capacity: 256 (æœ€å¤§èŠ‚ç‚¹æ•°)                  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  RegistryEntry[0]                              â”‚ â”‚
â”‚  â”‚  â€¢ node_id: "node_18f2a3b4c5d6"               â”‚ â”‚
â”‚  â”‚  â€¢ shm_name: "/librpc_node_12345_abc123"      â”‚ â”‚
â”‚  â”‚  â€¢ pid: 12345                                  â”‚ â”‚
â”‚  â”‚  â€¢ last_heartbeat: timestamp                   â”‚ â”‚
â”‚  â”‚  â€¢ flags: valid | active                       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”‚  RegistryEntry[1]                              â”‚ â”‚
â”‚  â”‚  ...                                           â”‚ â”‚
â”‚  â”‚  RegistryEntry[255]                            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Registryçš„ä¸‰ä¸ªä½œç”¨**ï¼š
1. **Nodeå‘ç°**ï¼šæ–°èŠ‚ç‚¹å¯åŠ¨æ—¶æŸ¥è¯¢ç°æœ‰èŠ‚ç‚¹
2. **å¿ƒè·³ç»´æŠ¤**ï¼šæ¯500msæ›´æ–°å¿ƒè·³ï¼Œæ¸…ç†è¿‡æœŸèŠ‚ç‚¹ï¼ˆ>3sï¼‰
3. **è¿æ¥æŸ¥æ‰¾**ï¼šå‘é€æ¶ˆæ¯æ—¶æŸ¥è¯¢ç›®æ ‡èŠ‚ç‚¹çš„å…±äº«å†…å­˜åç§°

### 4.2 Nodeæ³¨å†Œæµç¨‹

```
Nodeå¯åŠ¨æµç¨‹ï¼š

1. åˆ›å»ºè‡ªå·±çš„NodeSharedMemory
   â”œâ”€ åç§°: /librpc_node_<PID>_<HASH>
   â”œâ”€ å¤§å°: 40MB (64é˜Ÿåˆ—é…ç½®)
   â””â”€ åˆå§‹åŒ–: Header + InboundQueue[0-63]

2. æ³¨å†Œåˆ°Registry
   â”œâ”€ æ‰“å¼€/åˆ›å»º /librpc_registry
   â”œâ”€ æŸ¥æ‰¾ç©ºé—²slot
   â””â”€ å†™å…¥: node_id, shm_name, pid, heartbeat

3. è®¾ç½®readyæ ‡å¿—
   â””â”€ ready.store(true) // å…è®¸å…¶ä»–èŠ‚ç‚¹è¿æ¥

4. å¯åŠ¨åå°çº¿ç¨‹
   â”œâ”€ receiveLoop: æ¥æ”¶æ¶ˆæ¯
   â””â”€ heartbeatLoop: æ›´æ–°å¿ƒè·³ + æ¸…ç†è¿‡æœŸèŠ‚ç‚¹
```

**Registryåˆå§‹åŒ–çš„åŸå­æ€§ä¿è¯**ï¼š

```cpp
// åˆ›å»ºè€…ï¼ˆç¬¬ä¸€ä¸ªè¿›ç¨‹ï¼‰
int fd = shm_open("/librpc_registry", O_CREAT | O_EXCL | O_RDWR, 0666);
// ... åˆå§‹åŒ–æ‰€æœ‰å­—æ®µ ...
registry->header.magic.store(0x4C525247, std::memory_order_release);

// è¯»å–è€…ï¼ˆåç»­è¿›ç¨‹ï¼‰
int retry = 0;
while (retry < 10) {
    uint32_t magic = registry->header.magic.load(std::memory_order_acquire);
    if (magic == 0x4C525247) break;  // éªŒè¯æˆåŠŸ
    std::this_thread::sleep_for(std::chrono::milliseconds(10));  // é‡è¯•
    retry++;
}
```

**å…³é”®è®¾è®¡**ï¼š
- âœ… O_EXCLåŸå­åˆ›å»ºï¼ˆåªæœ‰ä¸€ä¸ªè¿›ç¨‹åˆ›å»ºæˆåŠŸï¼‰
- âœ… Release-Acquireè¯­ä¹‰ï¼ˆç¡®ä¿åˆå§‹åŒ–é¡ºåºï¼‰
- âœ… é‡è¯•æœºåˆ¶ï¼ˆé¿å…åˆå§‹åŒ–çª—å£æœŸçš„"Invalid magic"é”™è¯¯ï¼‰

### 4.3 Nodeè¿æ¥æœºåˆ¶ï¼ˆæ‡’æƒ°è¿æ¥ï¼‰

Nodeä¹‹é—´çš„è¿æ¥æ˜¯**æ‡’æƒ°å»ºç«‹**çš„ï¼Œå³**é¦–æ¬¡å‘é€æ¶ˆæ¯æ—¶**æ‰å»ºç«‹è¿æ¥ã€‚

```
è¿æ¥å»ºç«‹æµç¨‹ï¼ˆNode A â†’ Node Bï¼‰ï¼š

1. Node Aé¦–æ¬¡å‘é€æ¶ˆæ¯ç»™Node B
   â””â”€ send("node_B", data, size)

2. æ£€æŸ¥è¿æ¥ç¼“å­˜
   â””â”€ remote_connections_.find("node_B") â†’ æœªæ‰¾åˆ°

3. ä»RegistryæŸ¥è¯¢Node Bä¿¡æ¯
   â”œâ”€ registry_.findNode("node_B", target_info)
   â””â”€ è·å–: shm_name = "/librpc_node_67890_def456"

4. æ‰“å¼€å¹¶æ˜ å°„Node Bçš„å…±äº«å†…å­˜
   â”œâ”€ shm_fd = shm_open(target_info.shm_name, O_RDWR, 0666)
   â””â”€ shm_ptr = mmap(nullptr, sizeof(NodeSharedMemory), ...)

5. éªŒè¯Node Bå·²å°±ç»ª
   â”œâ”€ magic == 0x4C525247 âœ“
   â””â”€ ready == true âœ“

6. åœ¨Node Bçš„å…±äº«å†…å­˜ä¸­åˆ†é…å…¥ç«™é˜Ÿåˆ—
   â”œâ”€ æŸ¥æ‰¾ç©ºé—²é˜Ÿåˆ—slot
   â”œâ”€ åŸå­å ç”¨: flags.compare_exchange_strong(0, 0x3)
   â”œâ”€ åˆå§‹åŒ–: sender_id = "node_A"
   â””â”€ åˆå§‹åŒ–åŒæ­¥åŸè¯­: pthread_cond æˆ– semaphore

7. ç¼“å­˜è¿æ¥ä¿¡æ¯
   â””â”€ remote_connections_["node_B"] = {shm_ptr, my_queue, ...}

8. å‘é€æ¶ˆæ¯
   â””â”€ my_queue->queue.tryWrite(data, size)
```

**è¿æ¥å…³ç³»ç¤ºæ„å›¾**ï¼š

```
Node A                          Node B
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ NodeSharedMemoryâ”‚            â”‚ NodeSharedMemoryâ”‚
â”‚ queues[0-31]    â”‚            â”‚ queues[0-31]    â”‚
â”‚   [0]: â† B â”€â”€â”€â”€â”€â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”   â”‚   [0]: â† A     â”‚
â”‚   [1]: â† C      â”‚        â”‚   â”‚   [1]: free    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚            â–²
RemoteConnection to B      â”‚            â”‚
â”œâ”€ shm_ptr: â†’ Bçš„å…±äº«å†…å­˜  â”‚            â”‚
â””â”€ my_queue: &B.queues[0]â”€â”€â”˜            â”‚
                                        â”‚
RemoteConnection to A                   â”‚
â”œâ”€ shm_ptr: â†’ Açš„å…±äº«å†…å­˜              â”‚
â””â”€ my_queue: &A.queues[0]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å…³é”®ä¼˜åŒ–**ï¼š
- âœ… **æ‡’æƒ°è¿æ¥**ï¼šä¸é¢„å…ˆå»ºç«‹æ‰€æœ‰è¿æ¥ï¼Œé™ä½å¯åŠ¨å¼€é”€
- âœ… **è¿æ¥ç¼“å­˜**ï¼šFast Pathç›´æ¥æŸ¥è¡¨ï¼ŒSlow Pathæ‰å»ºç«‹è¿æ¥
- âœ… **åŒå‘ç‹¬ç«‹**ï¼šAâ†’Bå’ŒBâ†’Aä½¿ç”¨ä¸åŒé˜Ÿåˆ—ï¼Œäº’ä¸å¹²æ‰°
- âœ… **åŸå­åˆ†é…**ï¼šCASç¡®ä¿é˜Ÿåˆ—slotä¸å†²çª

### 4.4 Nodeå‘ç°æœºåˆ¶

Nodeå‘ç°**ä¸é€šè¿‡å®šæœŸæ‰«æRegistry**ï¼Œè€Œæ˜¯é€šè¿‡ä»¥ä¸‹æœºåˆ¶ï¼š

#### 4.4.1 å¯åŠ¨æ—¶ä¸»åŠ¨æŸ¥è¯¢

```cpp
void NodeImpl::initialize() {
    // 1. æ³¨å†Œåˆ°Registry
    shm_transport_v3_->initialize(node_id_);
    
    // 2. æŸ¥è¯¢ç°æœ‰æœåŠ¡ï¼ˆè§¦å‘è¿æ¥å»ºç«‹ï¼‰
    queryRemoteServices();  // å¹¿æ’­ç©ºçš„SERVICE_REGISTERæ¶ˆæ¯
    
    // 3. å¹¿æ’­NODE_JOINäº‹ä»¶
    broadcastNodeEvent(true);
}
```

**æŸ¥è¯¢æµç¨‹**ï¼š
```
Node Aå¯åŠ¨
   â†“
queryRemoteServices() 
   â†“
å¹¿æ’­ç©ºSERVICE_REGISTER (payload_len=0)
   â†“
Node B/Cæ”¶åˆ°æŸ¥è¯¢ â†’ å›å¤è‡ªå·±çš„æœåŠ¡åˆ—è¡¨
   â†“
Node Aæ”¶åˆ°å›å¤ â†’ è‡ªåŠ¨å»ºç«‹è¿æ¥ï¼ˆæ‡’æƒ°è¿æ¥è§¦å‘ï¼‰
```

#### 4.4.2 å¿ƒè·³è¶…æ—¶æ£€æµ‹

```cpp
void SharedMemoryTransportV3::heartbeatLoop() {
    while (running_) {
        // 1. æ›´æ–°è‡ªå·±çš„å¿ƒè·³
        registry_.updateHeartbeat(node_id_);
        
        // 2. æ¸…ç†è¿‡æœŸèŠ‚ç‚¹ï¼ˆ>3ç§’æ— å¿ƒè·³ï¼‰
        std::vector<NodeInfo> nodes_before = registry_.getAllNodes();
        int cleaned = registry_.cleanupStaleNodes(3000);
        
        // 3. å¯¹æ¯”æ‰¾å‡ºè¢«åˆ é™¤çš„èŠ‚ç‚¹ï¼Œè§¦å‘NODE_LEFTäº‹ä»¶
        if (cleaned > 0) {
            auto nodes_after = registry_.getAllNodes();
            for (const auto& node : nodes_before) {
                if (!existsIn(node, nodes_after)) {
                    node_impl_->handleNodeEvent(node.node_id, false);
                }
            }
        }
        
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }
}
```

**æ•ˆæœ**ï¼š
- âœ… å´©æºƒèŠ‚ç‚¹2-5ç§’å†…è‡ªåŠ¨å‘ç°å¹¶æ¸…ç†
- âœ… è‡ªåŠ¨è§¦å‘NODE_LEFTäº‹ä»¶
- âœ… æœåŠ¡å‘ç°è‡ªåŠ¨æ›´æ–°

---

## 5. æœåŠ¡å‘ç°æœºåˆ¶

### 5.1 ä¸¤å±‚æœåŠ¡æ³¨å†Œè¡¨

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         GlobalRegistry (è¿›ç¨‹å†…ï¼Œå•ä¾‹)               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ nodes_: map<node_id, NodeImpl>               â”‚  â”‚
â”‚  â”‚ services_: map<group, vector<ServiceDesc>>   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–²                               â–²
         â”‚                               â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚ Node A  â”‚                    â”‚ Node B  â”‚
    â”‚(è¿›ç¨‹å†…) â”‚                    â”‚(è¿›ç¨‹å†…) â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                               â”‚
         â”‚   SharedMemoryæ¶ˆæ¯ä¼ è¾“         â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           SERVICE_REGISTER / UNREGISTER
```

**è®¾è®¡åŸåˆ™**ï¼š
- âœ… **è¿›ç¨‹å†…**ï¼šç”¨GlobalRegistryï¼ˆå†…å­˜ï¼Œå¿«é€Ÿï¼‰
- âœ… **è·¨è¿›ç¨‹**ï¼šç”¨æ¶ˆæ¯å¹¿æ’­ï¼ˆSharedMemoryä¼ è¾“ï¼‰
- âœ… **æ— ä¸­å¿ƒåŒ–**ï¼šä¸ä¾èµ–å•ç‚¹æœåŠ¡æ³¨å†Œä¸­å¿ƒ

### 5.2 æœåŠ¡æ³¨å†Œæµç¨‹

```
Node Aæ³¨å†ŒæœåŠ¡ "sensor/temperature"ï¼š

1. æ³¨å†Œåˆ°GlobalRegistryï¼ˆè¿›ç¨‹å†…ï¼‰
   â””â”€ GlobalRegistry::instance().registerService("sensor", svc)

2. é€šçŸ¥è¿›ç¨‹å†…å…¶ä»–èŠ‚ç‚¹ï¼ˆåŒæ­¥ï¼‰
   â””â”€ for each node in process:
        node->handleServiceUpdate(svc, true)

3. å¹¿æ’­åˆ°è¿œç¨‹èŠ‚ç‚¹ï¼ˆå¼‚æ­¥ï¼‰
   â”œâ”€ åºåˆ—åŒ–æœåŠ¡æè¿°
   â”œâ”€ æ„å»ºSERVICE_REGISTERæ¶ˆæ¯
   â””â”€ shm_transport_v3_->broadcast(packet)
```

### 5.3 æœåŠ¡å‘ç°æµç¨‹

```
Node BæŸ¥è¯¢æœåŠ¡ï¼š

æ–¹å¼1: ä¸»åŠ¨æŸ¥è¯¢ï¼ˆå¯åŠ¨æ—¶ï¼‰
   â”œâ”€ queryRemoteServices()
   â”œâ”€ å¹¿æ’­ç©ºSERVICE_REGISTER (payload_len=0)
   â””â”€ å…¶ä»–èŠ‚ç‚¹æ”¶åˆ° â†’ å›å¤æ‰€æœ‰æœåŠ¡

æ–¹å¼2: è¢«åŠ¨æ¥æ”¶ï¼ˆè¿è¡Œæ—¶ï¼‰
   â”œâ”€ æ”¶åˆ°SERVICE_REGISTERæ¶ˆæ¯
   â”œâ”€ è§£ææœåŠ¡æè¿°
   â””â”€ æ›´æ–°GlobalRegistry

æ–¹å¼3: è®¢é˜…é€šçŸ¥ï¼ˆå®æ—¶ï¼‰
   â”œâ”€ subscribe("sensor", "temperature", callback)
   â”œâ”€ å¹¿æ’­SUBSCRIBEæ¶ˆæ¯
   â””â”€ å‘å¸ƒè€…è‡ªåŠ¨æ¨é€æ›´æ–°
```

### 5.4 ä¸å…±äº«å†…å­˜çš„å…³ç³»

| æœºåˆ¶ | ä½¿ç”¨çš„å…±äº«å†…å­˜ | ä¼ è¾“æ–¹å¼ |
|-----|--------------|---------|
| **Nodeæ³¨å†Œ** | `/librpc_registry` | ç›´æ¥å†™å…¥Registry |
| **Nodeå‘ç°** | æŸ¥è¯¢Registry + å¿ƒè·³æ£€æµ‹ | atomic load |
| **Nodeè¿æ¥** | `/librpc_node_PID_HASH` | mmapæ˜ å°„ |
| **æœåŠ¡æ³¨å†Œ** | GlobalRegistryï¼ˆè¿›ç¨‹å†…ï¼‰ | å†…å­˜ |
| **æœåŠ¡åŒæ­¥** | SharedMemoryä¼ è¾“ | InboundQueue |
| **æ¶ˆæ¯ä¼ è¾“** | InboundQueue (SPSC) | æ— é”é˜Ÿåˆ— |

**å…³é”®è®¾è®¡**ï¼š
- âœ… **Registryè½»é‡**ï¼šä»…å­˜å‚¨Nodeå…ƒä¿¡æ¯ï¼Œä¸å­˜å‚¨æœåŠ¡æ•°æ®
- âœ… **æœåŠ¡åŒæ­¥**ï¼šé€šè¿‡æ¶ˆæ¯å¹¿æ’­ï¼Œé¿å…ä¸­å¿ƒåŒ–ç“¶é¢ˆ
- âœ… **æ‡’æƒ°è¿æ¥**ï¼šé¦–æ¬¡å‘é€æ—¶æ‰æ˜ å°„å¯¹æ–¹å…±äº«å†…å­˜
- âœ… **åŒå‘ç‹¬ç«‹**ï¼šæ¯ä¸ªæ–¹å‘ç‹¬ç«‹çš„SPSCé˜Ÿåˆ—

---

## 6. é€šçŸ¥æœºåˆ¶å¯¹æ¯”

### 5.1 ä¸‰é‡æ¸…ç†æœºåˆ¶ï¼ˆv3.0å¢å¼ºï¼‰

LibRPC é‡‡ç”¨**å¼•ç”¨è®¡æ•° + PIDæ£€æµ‹ + å¿ƒè·³ç›‘æ§**ä¸‰é‡æ¸…ç†æœºåˆ¶ï¼Œç¡®ä¿å…±äº«å†…å­˜èµ„æºä¸æ³„æ¼ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            èµ„æºæ¸…ç†å†³ç­–æ ‘ (v3.0)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  è¿›ç¨‹é€€å‡ºï¼Ÿ    â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚          â”‚
          Normal â”‚          â”‚ Abnormal (kill -9 / crash)
                 â–¼          â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ ææ„å‡½æ•°   â”‚  â”‚ å¿ƒè·³è¶…æ—¶æ£€æµ‹    â”‚
        â”‚ æ‰§è¡Œ       â”‚  â”‚ (2-5ç§’)        â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                â”‚
                 â”‚      â”‚ PIDæ£€æµ‹æ¸…ç†    â”‚
                 â”‚      â”‚ (ä¸‹æ¬¡å¯åŠ¨)      â”‚
                 â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â–¼          â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  ref_count--               â”‚
        â”‚  if (ref_count == 0)       â”‚
        â”‚    shm_unlink()            â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  èµ„æºå·²é‡Šæ”¾    â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 7.2 å¼•ç”¨è®¡æ•°æ¸…ç†

**é€‚ç”¨åœºæ™¯**ï¼šæ­£å¸¸é€€å‡ºï¼ˆexit, return, SIGTERMï¼‰

**å®ç°**ï¼š
```cpp
class LargeDataChannel {
    ~LargeDataChannel() {
        if (!control_) return;
        
        // é€’å‡å¼•ç”¨è®¡æ•°
        int32_t prev = control_->ref_count.fetch_sub(1, 
                                    std::memory_order_acq_rel);
        
        std::cout << "[LargeData] Destructor: " << shm_name_ 
                  << ", ref_count: " << prev << " -> " << (prev - 1) 
                  << std::endl;
        
        // æœ€åä¸€ä¸ªå¼•ç”¨ï¼Œåˆ é™¤å…±äº«å†…å­˜
        if (prev == 1) {
            munmap(shm_addr_, shm_size_);
            close(shm_fd_);
            shm_unlink(shm_name_.c_str());  // âœ“ ç«‹å³æ¸…ç†
            std::cout << "[LargeData] Last reference, unlinked: " 
                      << shm_name_ << std::endl;
        }
    }
};
```

**æ•ˆæœ**ï¼š
- âœ… æ­£å¸¸é€€å‡ºæ—¶ç«‹å³æ¸…ç†
- âœ… å¤šè¿›ç¨‹åœºæ™¯ï¼Œæœ€åé€€å‡ºçš„è¿›ç¨‹è´Ÿè´£æ¸…ç†
- âŒ å¼‚å¸¸é€€å‡ºï¼ˆkill -9ï¼‰æ—¶æ— æ³•æ‰§è¡Œ

### 7.3 å¿ƒè·³è¶…æ—¶æ¸…ç†ï¼ˆv3.0æ–°å¢ï¼‰

**é€‚ç”¨åœºæ™¯**ï¼šè¿›ç¨‹å´©æºƒã€kill -9ï¼ˆå¿«é€Ÿæ£€æµ‹ï¼‰

**å®ç°**ï¼š
```cpp
void SharedMemoryTransportV3::heartbeatLoop() {
    while (running_) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        
        // æ£€æµ‹è¶…æ—¶èŠ‚ç‚¹
        for (auto it = node_shm_map_.begin(); it != node_shm_map_.end();) {
            uint64_t last_hb = it->second.header->last_heartbeat.load();
            uint64_t now = getCurrentTimestamp();
            
            if (now - last_hb > 5000) {  // 5ç§’è¶…æ—¶
                // æ¸…ç†èŠ‚ç‚¹å…±äº«å†…å­˜
                munmap(it->second.addr, it->second.size);
                close(it->second.fd);
                
                // è§¦å‘NODE_LEFTäº‹ä»¶
                if (node_impl_) {
                    node_impl_->handleNodeEvent(it->first, false);
                }
                
                it = node_shm_map_.erase(it);
            } else {
                ++it;
            }
        }
    }
}
```

**æ•ˆæœ**ï¼š
- âœ… å´©æºƒèŠ‚ç‚¹2-5ç§’å†…æ£€æµ‹å¹¶æ¸…ç†
- âœ… æ— éœ€é‡å¯è¿›ç¨‹
- âœ… è‡ªåŠ¨è§¦å‘æœåŠ¡å‘ç°æ›´æ–°

### 7.4 PIDæ£€æµ‹æ¸…ç†

**é€‚ç”¨åœºæ™¯**ï¼šå¼‚å¸¸é€€å‡ºï¼ˆkill -9, å´©æºƒï¼‰åé‡å¯

**å®ç°**ï¼š
```cpp
// é¦–æ¬¡åˆ›å»ºé€šé“æ—¶è‡ªåŠ¨æ¸…ç†
std::shared_ptr<LargeDataChannel> LargeDataChannel::create(...) {
    static std::atomic<bool> g_cleanup_performed{false};
    
    if (!g_cleanup_performed.exchange(true)) {
        std::cout << "[LargeData] First channel creation, "
                  << "performing startup cleanup..." << std::endl;
        cleanupOrphanedChannels(60);  // âœ“ PIDæ£€æµ‹
    }
    
    // åˆ›å»ºé€šé“...
}

// æ¸…ç†å­¤å„¿é€šé“
size_t LargeDataChannel::cleanupOrphanedChannels(uint32_t timeout_seconds) {
    DIR* dir = opendir("/dev/shm");
    
    while ((entry = readdir(dir)) != nullptr) {
        // åªå¤„ç†*channel*æ–‡ä»¶
        if (name.find("channel") == std::string::npos) continue;
        
        // æ˜ å°„å…±äº«å†…å­˜
        void* addr = mmap(...);
        RingBufferControl* control = static_cast<RingBufferControl*>(addr);
        
        // âœ“ ä¼˜å…ˆçº§1: PIDæ£€æµ‹ï¼ˆæœ€å¿«ã€æœ€å‡†ç¡®ï¼‰
        int32_t writer_pid = control->writer_pid.load();
        int32_t reader_pid = control->reader_pid.load();
        
        bool writer_alive = isProcessAlive(writer_pid);
        bool reader_alive = isProcessAlive(reader_pid);
        
        if ((writer_pid > 0 || reader_pid > 0) && 
            !writer_alive && !reader_alive) {
            // ä¸¤ä¸ªè¿›ç¨‹éƒ½ä¸å­˜åœ¨ï¼Œç«‹å³æ¸…ç†
            shm_unlink(name.c_str());  // âœ“
            continue;
        }
        
        // âœ“ ä¼˜å…ˆçº§2: å¼•ç”¨è®¡æ•°æ£€æµ‹
        if (control->ref_count == 0) {
            shm_unlink(name.c_str());
            continue;
        }
        
        // âœ“ ä¼˜å…ˆçº§3: å¿ƒè·³è¶…æ—¶æ£€æµ‹ï¼ˆfallbackï¼‰
        if (heartbeatTimeout(control, timeout_seconds)) {
            shm_unlink(name.c_str());
        }
    }
}

// PIDå­˜æ´»æ£€æµ‹
static bool isProcessAlive(int32_t pid) {
    if (pid <= 0) return false;
    
    // kill(pid, 0) ä¸å‘é€ä¿¡å·ï¼Œåªæ£€æŸ¥è¿›ç¨‹æ˜¯å¦å­˜åœ¨
    if (kill(pid, 0) == 0) {
        return true;  // è¿›ç¨‹å­˜åœ¨
    }
    
    // ESRCH: è¿›ç¨‹ä¸å­˜åœ¨
    // EPERM: è¿›ç¨‹å­˜åœ¨ä½†æ— æƒé™ï¼ˆä¹Ÿç®—å­˜æ´»ï¼‰
    return errno != ESRCH;
}
```

**æ•ˆæœ**ï¼š
- âœ… kill -9åï¼Œä¸‹æ¬¡å¯åŠ¨ç«‹å³æ¸…ç†ï¼ˆ<100msï¼‰
- âœ… ç²¾ç¡®åˆ¤æ–­ï¼ˆPIDæ£€æµ‹ï¼‰
- âœ… æ€§èƒ½ä¼˜åŒ–ï¼ˆç›®å½•æ‰«æï¼Œéæš´åŠ›å°è¯•ï¼‰

### 7.5 æ¸…ç†æ€§èƒ½å¯¹æ¯”ï¼ˆv3.0ï¼‰

| æ–¹æ³• | å»¶è¿Ÿ | å‡†ç¡®æ€§ | æ“ä½œæ¬¡æ•° | åº”ç”¨åœºæ™¯ |
|-----|------|--------|---------|---------|
| **å¼•ç”¨è®¡æ•°** | 0msï¼ˆå³æ—¶ï¼‰ | 100% | O(1) | æ­£å¸¸é€€å‡º âœ“ |
| **å¿ƒè·³è¶…æ—¶** | 2-5s | 99% | O(1) | å´©æºƒæ£€æµ‹ âœ“ |
| **PIDæ£€æµ‹** | <100ms | 99.9% | O(N)æ–‡ä»¶æ‰«æ | å¯åŠ¨æ¸…ç† âœ“ |

---

## 8. æ€§èƒ½ä¼˜åŒ–

### 8.1 æ— é”é˜Ÿåˆ—

**SPSCé˜Ÿåˆ—**ï¼ˆSingle Producer Single Consumerï¼‰ï¼š

```cpp
template<size_t Capacity>
class LockFreeRingBuffer {
private:
    alignas(64) std::atomic<uint64_t> head_;  // å†™æŒ‡é’ˆ
    alignas(64) std::atomic<uint64_t> tail_;  // è¯»æŒ‡é’ˆ
    alignas(64) uint8_t buffer_[Capacity];    // æ•°æ®ç¼“å†²åŒº
    
public:
    bool enqueue(const uint8_t* data, size_t size) {
        uint64_t current_head = head_.load(std::memory_order_relaxed);
        uint64_t current_tail = tail_.load(std::memory_order_acquire);
        
        // æ£€æŸ¥ç©ºé—´
        uint64_t available = Capacity - (current_head - current_tail);
        if (size + sizeof(Header) > available) {
            return false;  // é˜Ÿåˆ—æ»¡
        }
        
        // å†™å…¥æ•°æ®ï¼ˆæ— é”ï¼ï¼‰
        // ...
        
        // æ›´æ–°å¤´æŒ‡é’ˆ
        head_.store(current_head + total_size, std::memory_order_release);
        return true;
    }
};
```

**å…³é”®æŠ€æœ¯**ï¼š
- âœ… Cache lineå¯¹é½ï¼ˆé¿å…false sharingï¼‰
- âœ… Memory orderä¼˜åŒ–ï¼ˆrelaxed/acquire/releaseï¼‰
- âœ… å•ç”Ÿäº§è€…å•æ¶ˆè´¹è€…ï¼ˆæ— ç«äº‰ï¼‰

### 8.2 é›¶æ‹·è´

**ä¼ ç»Ÿæ–¹å¼**ï¼ˆ2æ¬¡æ‹·è´ï¼‰ï¼š
```cpp
// âŒ æ‹·è´æ–¹å¼
std::vector<uint8_t> recv_buffer(size);
shm_read(shm_addr, recv_buffer.data(), size);  // Copy 1
processData(recv_buffer);                      // Copy 2ï¼ˆå¯èƒ½ï¼‰
```

**é›¶æ‹·è´æ–¹å¼**ï¼ˆ0æ¬¡æ‹·è´ï¼‰ï¼š
```cpp
// âœ… é›¶æ‹·è´
DataBlock block;
channel->tryRead(block);  // block.data ç›´æ¥æŒ‡å‘å…±äº«å†…å­˜

processData(block.data, block.header.size);  // ç›´æ¥è®¿é—®ï¼Œæ— æ‹·è´ï¼âœ“

channel->releaseBlock(block);
```

**æ€§èƒ½æå‡**ï¼š
- 1MBæ•°æ®ï¼šçœç•¥2MBæ‹·è´ â†’ **2å€æ€§èƒ½**
- 4MBæ•°æ®ï¼šçœç•¥8MBæ‹·è´ â†’ **2å€æ€§èƒ½**

### 8.3 MAP_NORESERVE ä¼˜åŒ–ï¼ˆLinuxï¼‰

**é—®é¢˜**ï¼š64MBå…±äº«å†…å­˜ç«‹å³åˆ†é…64MBç‰©ç†å†…å­˜

**è§£å†³**ï¼šå»¶è¿Ÿåˆ†é…ç‰©ç†å†…å­˜
```cpp
#ifndef __QNXNTO__
void* addr = mmap(nullptr, shm_size, PROT_READ | PROT_WRITE,
                  MAP_SHARED | MAP_NORESERVE,  // âœ“ Linuxå…³é”®ï¼
                  fd, 0);
#else
void* addr = mmap(nullptr, shm_size, PROT_READ | PROT_WRITE,
                  MAP_SHARED,  // QNXä¸æ”¯æŒMAP_NORESERVE
                  fd, 0);
#endif
```

**æ•ˆæœ**ï¼š
- è™šæ‹Ÿå†…å­˜ï¼š64MBï¼ˆç«‹å³åˆ†é…ï¼‰
- ç‰©ç†å†…å­˜ï¼šæŒ‰éœ€åˆ†é…ï¼ˆå®é™…ä½¿ç”¨æ—¶ï¼‰
- èŠ‚çœå†…å­˜ï¼šæœªä½¿ç”¨éƒ¨åˆ†ä¸å ç”¨ç‰©ç†RAM
- **QNXå·®å¼‚**ï¼šç«‹å³åˆ†é…ç‰©ç†å†…å­˜

### 8.4 Cache Lineå¯¹é½

```cpp
// âœ… Cache lineå¯¹é½ï¼ˆ64å­—èŠ‚ï¼‰
struct alignas(64) RingBufferControl {
    std::atomic<uint64_t> write_pos;  // Cache line 0
    // ...
} __attribute__((aligned(64)));

struct alignas(64) InboundQueue {
    char sender_id[64];               // Cache line 0
    std::atomic<uint32_t> flags;      // Cache line 1
    // ...
    char padding[56];                 // å¡«å……åˆ°64å­—èŠ‚
} __attribute__((aligned(64)));
```

**é¿å…False Sharing**ï¼š
- ä¸åŒCPUæ ¸å¿ƒè®¿é—®ä¸åŒçš„cache line
- é¿å…ä¸å¿…è¦çš„cacheåŒæ­¥å¼€é”€
- æ€§èƒ½æå‡ï¼š~10-20%

---

## 9. è®¾è®¡æƒè¡¡

### 9.1 å†…å­˜å ç”¨ vs é˜Ÿåˆ—å®¹é‡

**v3.0é€‰æ‹©**ï¼šé…ç½®åŒ–é˜Ÿåˆ—å‚æ•°

| æ–¹æ¡ˆ | å†…å­˜å ç”¨ | é˜Ÿåˆ—å®¹é‡ | å¹¶å‘æ€§èƒ½ | å†³ç­– |
|-----|---------|---------|---------|------|
| **æœ€å°é…ç½®** | 8MB | 64Ã—16 | ä½ | åµŒå…¥å¼ |
| **é»˜è®¤é…ç½®** | 40MB | 64é˜Ÿåˆ— | ä¸­ | âœ… æ¨è |
| **é«˜æ€§èƒ½é…ç½®** | 132MB | 1024Ã—64 | é«˜ | æœåŠ¡å™¨ |

**ç†ç”±**ï¼šä¸åŒåœºæ™¯éœ€æ±‚ä¸åŒï¼Œæä¾›é…ç½®åŒ–é€‰é¡¹ã€‚

### 9.2 å¿ƒè·³ vs PIDæ£€æµ‹

**v3.0é€‰æ‹©**ï¼šå¿ƒè·³ + PIDï¼ˆäº’è¡¥ï¼‰

| æ–¹æ¡ˆ | å»¶è¿Ÿ | å‡†ç¡®æ€§ | å…¼å®¹æ€§ | å†³ç­– |
|-----|------|--------|--------|------|
| **ä»…å¿ƒè·³** | 2-5s | 99% | é«˜ | âš ï¸ å»¶è¿Ÿè¾ƒé•¿ |
| **ä»…PID** | <100ms | 99.9% | ä¸­ | âš ï¸ éœ€é‡å¯ |
| **å¿ƒè·³ + PID** | 2-5s + <100ms | 99.9% | é«˜ | âœ… é‡‡ç”¨ |

**ç†ç”±**ï¼š
- å¿ƒè·³æä¾›è¿è¡Œæ—¶æ£€æµ‹ï¼ˆæ— éœ€é‡å¯ï¼‰
- PIDæä¾›å¯åŠ¨æ—¶æ¸…ç†ï¼ˆå¿«é€Ÿæ¢å¤ï¼‰
- ä¸¤è€…äº’è¡¥ï¼Œè¦†ç›–æ‰€æœ‰åœºæ™¯

### 9.3 å¤šè¯»è€… vs å•è¯»è€…

**v3.0é€‰æ‹©**ï¼šå•è¯»è€…ï¼ˆSPSCï¼‰

| æ–¹æ¡ˆ | æ€§èƒ½ | å¤æ‚åº¦ | åœºæ™¯ | å†³ç­– |
|-----|------|--------|------|------|
| **SPSC** | é«˜ï¼ˆæ— é”ï¼‰ | ä½ | ç‚¹å¯¹ç‚¹ | âœ… é‡‡ç”¨ |
| **SPMC** | ä¸­ï¼ˆéœ€é”ï¼‰ | ä¸­ | å¹¿æ’­ | âŒ æŒ‰éœ€å®ç° |
| **MPMC** | ä½ï¼ˆé‡é”ï¼‰ | é«˜ | é€šç”¨ | âŒ ä¸éœ€è¦ |

**ç†ç”±**ï¼šå¤§éƒ¨åˆ†åœºæ™¯æ˜¯ç‚¹å¯¹ç‚¹æˆ–å‘å¸ƒ-è®¢é˜…ï¼ˆå¤šä¸ªSPSCï¼‰ï¼Œæ— éœ€MPMCã€‚

### 9.4 CRC32 vs æ— æ ¡éªŒ

**v3.0é€‰æ‹©**ï¼šCRC32æ ¡éªŒ

| æ–¹æ¡ˆ | å¯é æ€§ | æ€§èƒ½å½±å“ | å†³ç­– |
|-----|--------|---------|------|
| **æ— æ ¡éªŒ** | ä½ | 0% | âŒ é£é™©é«˜ |
| **CRC32** | ä¸­ | ~2-5% | âœ… é‡‡ç”¨ |
| **SHA256** | é«˜ | ~20-30% | âŒ è¿‡åº¦ |

**ç†ç”±**ï¼šå…±äº«å†…å­˜å¶å°”ä¼šæŸåï¼ˆç¡¬ä»¶æ•…éšœã€å†…æ ¸bugï¼‰ï¼ŒCRC32å¼€é”€å°ä¸”è¶³å¤Ÿã€‚

---

## é™„å½•

### A. æ€§èƒ½æµ‹è¯•æ•°æ®ï¼ˆv3.0ï¼‰

#### A.1 å»¶è¿Ÿåˆ†å¸ƒï¼ˆå•ä½ï¼šÎ¼sï¼‰

| ä¼ è¾“ç±»å‹ | æ¶ˆæ¯å¤§å° | P50 | P90 | P99 | P99.9 |
|---------|---------|-----|-----|-----|-------|
| InProcess | 256B | 0.5 | 0.8 | 1.2 | 2.0 |
| SharedMemory V3 | 256B | 8 | 12 | 15 | 25 |
| LargeDataChannel | 1MB | 35 | 60 | 80 | 150 |
| LargeDataChannel | 4MB | 120 | 180 | 250 | 400 |

#### A.2 ååé‡æµ‹è¯•

| ä¼ è¾“ç±»å‹ | å—å¤§å° | é¢‘ç‡ | ååé‡ | CPUå ç”¨ |
|---------|-------|------|--------|---------|
| SharedMemory V3 | 256B | 200K/s | 50 MB/s | 15% |
| LargeDataChannel | 1MB | 135/s | 135 MB/s | 8% |
| LargeDataChannel | 4MB | 27/s | 110 MB/s | 7% |
| LargeDataChannel | 8MB | 14/s | 112 MB/s | 6% |

### B. å†…å­˜å¸ƒå±€è¯¦æƒ…ï¼ˆv3.0ä¼˜åŒ–ï¼‰

#### B.1 SharedMemory V3 èŠ‚ç‚¹ï¼ˆé»˜è®¤é…ç½®ï¼‰

```
æ€»å¤§å°ï¼š40MBï¼ˆ64é˜Ÿåˆ— Ã— (512KBæ•°æ® + 128KBæ§åˆ¶)ï¼‰

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” 0x0000
â”‚  NodeHeader (64B)                   â”‚
â”‚  â€¢ magic, version, num_queues       â”‚
â”‚  â€¢ owner_pid, heartbeat, ready      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ 0x0040
â”‚  InboundQueue[0] (0.5MB)            â”‚
â”‚  â€¢ sender_id, flags                 â”‚
â”‚  â€¢ LockFreeRingBuffer<256>          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ 0x080040
â”‚  InboundQueue[1] (0.5MB)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ...                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  InboundQueue[31] (0.5MB)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ 40MB
```

#### B.2 LargeDataChannel

```
æ€»å¤§å°ï¼š64MBï¼ˆé»˜è®¤ï¼‰

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” 0x0000
â”‚  RingBufferControl (64B)            â”‚
â”‚  â€¢ write_pos, read_pos, sequence    â”‚
â”‚  â€¢ reader_pid, writer_pid           â”‚
â”‚  â€¢ ref_count, capacity              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ 0x0040
â”‚  Ring Buffer (64MB - 64B)           â”‚
â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ LargeDataHeader (128B)      â”‚   â”‚
â”‚  â”‚ Payload (variable)          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ LargeDataHeader (128B)      â”‚   â”‚
â”‚  â”‚ Payload (variable)          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  ...                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ 64MB
```

---

**æœ€åæ›´æ–°**: 2025-11-26  
**ç‰ˆæœ¬**: 3.0
